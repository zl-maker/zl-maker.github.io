<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Git学习笔记 | zl-maker的个人博客</title><meta name="keywords" content="Git"><meta name="author" content="zl-maker"><meta name="copyright" content="zl-maker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Ⅰ-Git 操作一、初始化 该处是用来提交时当作签名使用的  git config --global user.name &quot;我的用户名&quot; git config --global user.email &quot;我的邮箱&quot; #删除配置信息 git config --global --unset user.name git config --global --unset user.email  二、Git 工">
<meta property="og:type" content="article">
<meta property="og:title" content="Git学习笔记">
<meta property="og:url" content="https://zl-maker.github.io/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="zl-maker的个人博客">
<meta property="og:description" content="Ⅰ-Git 操作一、初始化 该处是用来提交时当作签名使用的  git config --global user.name &quot;我的用户名&quot; git config --global user.email &quot;我的邮箱&quot; #删除配置信息 git config --global --unset user.name git config --global --unset user.email  二、Git 工">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2021-12-19T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-07T04:20:43.906Z">
<meta property="article:author" content="zl-maker">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/zl-maker/DrawingBed@img/image/1636982024781rocked.png"><link rel="canonical" href="https://zl-maker.github.io/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e18b855c8e728d9f1e9bd1cf01ef102f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: zl-maker","link":"链接: ","source":"来源: zl-maker的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-07 12:20:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/zl-maker/DrawingBed@img/image/1635148748379-星图.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/say/"><i class="fa-fw fas fa-bomb"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">zl-maker的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/say/"><i class="fa-fw fas fa-bomb"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Git学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-19T16:00:00.000Z" title="发表于 2021-12-20 00:00:00">2021-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-07T04:20:43.906Z" title="更新于 2022-05-07 12:20:43">2022-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Git学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Ⅰ-Git-操作"><a href="#Ⅰ-Git-操作" class="headerlink" title="Ⅰ-Git 操作"></a>Ⅰ-Git 操作</h1><h2 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h2><blockquote>
<p>该处是用来提交时当作签名使用的</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config --global user.name <span class="token string">"我的用户名"</span>
<span class="token function">git</span> config --global user.email <span class="token string">"我的邮箱"</span>
<span class="token comment">#删除配置信息</span>
<span class="token function">git</span> config --global --unset user.name
<span class="token function">git</span> config --global --unset user.email<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="二、Git-工作流程与区域"><a href="#二、Git-工作流程与区域" class="headerlink" title="二、Git 工作流程与区域"></a>二、Git 工作流程与区域</h2><h3 id="1、区域"><a href="#1、区域" class="headerlink" title="1、区域"></a>1、区域</h3><ol>
<li><p>工作区</p>
<blockquote>
<p>平时写代码的文件目录</p>
</blockquote>
</li>
<li><p>暂存区</p>
<blockquote>
<p>git add 后提交暂存的地方</p>
</blockquote>
</li>
<li><p>版本库</p>
<blockquote>
<p>git commit 后给你生成版本的地方,注意 push 是提交到远程仓库而不是版本库,请勿混淆</p>
</blockquote>
</li>
</ol>
<h3 id="2、工作流程"><a href="#2、工作流程" class="headerlink" title="2、工作流程"></a>2、工作流程</h3><blockquote>
<p>每个项目都有一个 Git 目录(.git)他是 Git 用来保存元数据和对象数据库的地方.该目录非常重要,每次克隆镜像仓库的时候,实际拷贝的就是这个目录里的数据</p>
</blockquote>
<h5 id="①、在工作目录中修改某些文件"><a href="#①、在工作目录中修改某些文件" class="headerlink" title="①、在工作目录中修改某些文件"></a>①、在工作目录中修改某些文件</h5><blockquote>
<p>从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录,这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的,接下去就可以在工作目录中对这些文件进行编辑</p>
</blockquote>
<h5 id="②、保存到暂存区域-对暂存区做快照"><a href="#②、保存到暂存区域-对暂存区做快照" class="headerlink" title="②、保存到暂存区域,对暂存区做快照"></a>②、保存到暂存区域,对暂存区做快照</h5><blockquote>
<p>暂存区域只不过是个简单的文件,一般都放在 Git 目录中,有时候人们会把这个区域的文件叫做索引文件,不过标准说法还是叫暂存区域</p>
</blockquote>
<h5 id="③、提交更新"><a href="#③、提交更新" class="headerlink" title="③、提交更新"></a>③、提交更新</h5><blockquote>
<p>将保存区在暂存区域的文件快照永久转储到本地数据库(Git 目录)中</p>
</blockquote>
<p>我们可以从文件所处位置来判断状态:如果是 Git 目录中保存着的特定版本文件,就属于提交版本;如果做了修改并已放入暂存区域,就属于已暂存状态;如果自上次去除后,做了修改但还没有放到暂存区域,就是已修改状态</p>
<h2 id="三、对象详解-底层命令"><a href="#三、对象详解-底层命令" class="headerlink" title="三、对象详解(底层命令)"></a>三、对象详解(底层命令)</h2><h3 id="1、git-对象"><a href="#1、git-对象" class="headerlink" title="1、git 对象"></a>1、git 对象</h3><blockquote>
<ol>
<li>key:val 组成的键值对(key 是 val 相应的 hash)</li>
</ol>
<p> 键值对在 git 内部是 blob 类型(git 特有)</p>
<ol start="2">
<li>存储数据文件内容,也称为数据对象</li>
</ol>
</blockquote>
<h5 id="①-直接写入-git-对象方法与读取-存入”-git-x2F-objects”"><a href="#①-直接写入-git-对象方法与读取-存入”-git-x2F-objects”" class="headerlink" title="① 直接写入 git 对象方法与读取(存入”.git&#x2F;objects”)"></a>① 直接写入 git 对象方法与读取(存入”.git&#x2F;objects”)</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#将打印内容写入对象(git数据库)并且返回其相应哈希值</span>
<span class="token builtin class-name">echo</span> <span class="token string">"写入的对象内容"</span> <span class="token operator">|</span> <span class="token function">git</span> hash-object -w --stdin
<span class="token comment">#读取内容并不能直接cat读取,因为git存入时已经加密,需要如下代码 -p:内容  -t:类型</span>
<span class="token function">git</span> cat-file -p 存入对象的哈希值<span class="token punctuation">(</span>此值可以由上一步得到<span class="token punctuation">)</span>
<span class="token comment">#将文件写入git对象,即我们常见的版本控制中出现的</span>
<span class="token function">git</span> hash-object -w ./test.txt
<span class="token comment">#查看Git存储的数据  返回其文件夹内的所有哈希文件</span>
<span class="token function">find</span> .git/objects -type f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2、树对象"><a href="#2、树对象" class="headerlink" title="2、树对象"></a>2、树对象</h3><blockquote>
<p>树对象是存储键值 作用为控制版本,如我们的版本前回退 就是在操作这个对象的(指向改变)</p>
<p>作用就是生成快照</p>
<p>这个也是 git 的必杀特性,因为他的切换分支与版本都很快 只是指针切换</p>
</blockquote>
<h4 id="构建树对象"><a href="#构建树对象" class="headerlink" title="构建树对象"></a>构建树对象</h4><blockquote>
<p>我们可以通过 update-index , write-tree , read-tree 等命令来构建树对象并且塞到暂存区</p>
</blockquote>
<h5 id="①-利用-update-index-命令-创建暂存区"><a href="#①-利用-update-index-命令-创建暂存区" class="headerlink" title="① 利用 update-index 命令 创建暂存区"></a>① 利用 <code>update-index</code> 命令 创建暂存区</h5><blockquote>
<p>利用 <code>update-index</code> 命令 为 test.txt 文件的首个版本创建一个暂存区,并通过<code>write-tree</code>命令生成树对象</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#1生成一个树对象</span>
<span class="token function">git</span> update-index --add --cacheinfo <span class="token number">100664</span><span class="token punctuation">(</span>文件状态码:普通文件<span class="token punctuation">)</span> 哈希值 对应文件名
<span class="token comment">#生成快照(树对象)</span>
<span class="token function">git</span> write-tree
<span class="token comment">#2 将第一个树对象加入第二个树对象,使其成为新的树对象</span>
<span class="token function">git</span> read-tree -prefix<span class="token operator">=</span>bak 哈希值<span class="token punctuation">(</span>树对象的<span class="token punctuation">)</span>
<span class="token function">git</span> write-tree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="②-查看暂存区当前样子"><a href="#②-查看暂存区当前样子" class="headerlink" title="② 查看暂存区当前样子"></a>② 查看暂存区当前样子</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> ls-files -s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="3、提交对象"><a href="#3、提交对象" class="headerlink" title="3、提交对象"></a>3、提交对象</h3><blockquote>
<ol>
<li>通过上述两个对象操作后,你会发现你已经生成了不同项目的快照,但是问题是:如果想重用这些快照,你必须记住所有三个 SHA-1(快照)哈希值 .但是,你也完全不知道是谁保存了这些快照,在什么时刻保存的,以及为什么保存这些快照.而以上这些,正是提交对象(commit object)能为你保存的基本信息</li>
<li>我们可以通过调用 commit-tree 命令创建一个提交对象,为此需要指定一个树对象的 SHA-1 值,为此需要指定一个树对象的 SHA-1 值 , 以及该提交的父提交对象(如果有的话,第一次将暂存区做快照就没有父对象)</li>
<li>真正的一个版本其实就是提交对象</li>
</ol>
</blockquote>
<h5 id="①-创建提交对象"><a href="#①-创建提交对象" class="headerlink" title="① 创建提交对象"></a>① 创建提交对象</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">echo</span> <span class="token string">"first commit"</span> <span class="token operator">|</span><span class="token function">git</span> commit-tree 树对象的哈希值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>② 指定一个树对象的 SHA-1 值 , 以及该提交的父提交对象</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">echo</span> <span class="token string">"second commit"</span> <span class="token operator">|</span> <span class="token function">git</span> commit-tree 提交的树对象哈希值 -p 父亲树对象哈希值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="四、高层命令"><a href="#四、高层命令" class="headerlink" title="四、高层命令"></a>四、高层命令</h2><h3 id="1、git-add"><a href="#1、git-add" class="headerlink" title="1、git add"></a>1、git add</h3><blockquote>
<ol>
<li><p>会将工作目录的修改,保存成 git 对象 <code>先到版本库,再到暂存区</code>,而不是直接到暂存区</p>
</li>
<li><p>在工作目录修改几个文件,就会生成几个 git 对象(一个文件对应一个 git 文件)</p>
</li>
<li><p>同一个文件,每次修改再 add 的时候都会生成一个新的 git 对象,是<code>增量</code>而不是覆盖</p>
</li>
<li><p>所以说 git 是绝对安全的,就算我只存到暂存区没有提交 git 也会给我保存</p>
</li>
<li><p>只有后面提交的时候,才会根据暂存区内容给我生成树对象并存入版本区,然后加上我们的提交信息,才生成提交对象存入版本库</p>
</li>
</ol>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#相当于以下两个命令集合</span>
<span class="token function">git</span> hash-object -w 文件名<span class="token punctuation">(</span>修改了多少个工作目录中的文件,就要被执行几次<span class="token punctuation">)</span>
<span class="token function">git</span> update-index <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="2、git-commit-m-“注释内容”"><a href="#2、git-commit-m-“注释内容”" class="headerlink" title="2、git commit -m “注释内容”"></a>2、git commit -m “注释内容”</h3><blockquote>
<p>将暂存区提交到版本库</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> write-tree
<span class="token function">git</span> commit-tree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>跳过暂存区存入(之前 add 过的,直接提交)</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> commit -a -m <span class="token string">""</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="3、git-init"><a href="#3、git-init" class="headerlink" title="3、git init"></a>3、git init</h3><blockquote>
<p>初始化仓库 初始化后,在当前目录下出现一个名为.git 的文件夹</p>
</blockquote>
<h3 id="4、git-status"><a href="#4、git-status" class="headerlink" title="4、git status"></a>4、git status</h3><blockquote>
<p>查看文件的状态</p>
</blockquote>
<h3 id="5、git-diff"><a href="#5、git-diff" class="headerlink" title="5、git diff"></a>5、git diff</h3><ol>
<li><p>当前做的那些更新没有暂存?</p>
<p>命令:<code>git diff</code>(不加参数直接输入 git diff)</p>
</li>
<li><p>有哪些更新已经暂存起来准备好了下次提交</p>
<p>命令:<code>git diff --cached</code>或者<code>git diff --staged(1.6.1以上版本)</code></p>
</li>
</ol>
<h3 id="6、git-log"><a href="#6、git-log" class="headerlink" title="6、git log"></a>6、git log</h3><blockquote>
<ol>
<li><p><code>git log</code>(不带参数)</p>
<p><code>空格键</code>往下翻页 <code>b</code>向上翻页 <code>q</code>退出日志查阅</p>
</li>
<li><p>git log –oneline</p>
<p>将日志信息拍成一行显示</p>
</li>
<li><p>git reflog</p>
<p>所有的日志信息</p>
</li>
<li><p>git log –oneline –decorate –graph –all</p>
<p>查看所有的分支信息命令</p>
</li>
</ol>
</blockquote>
<h3 id="7、git-rm"><a href="#7、git-rm" class="headerlink" title="7、git rm"></a>7、git rm</h3><blockquote>
<p>删除工作目录对应的文件,再将修改添加到暂存区(如同删除后给你用了 <code>git add 文件名</code>)</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#删除命令</span>
<span class="token function">git</span> <span class="token function">rm</span> 文件名
<span class="token comment">#直接提交修改,因为rm命令帮你提交到暂存区了</span>
<span class="token function">git</span> commit -m <span class="token string">"xxx"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8、git-mv"><a href="#8、git-mv" class="headerlink" title="8、git mv"></a>8、git mv</h3><blockquote>
<p>将工作目录中的文件进行重命名,再将修改添加到暂存区</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> <span class="token function">mv</span> 原文件名  新文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="五、配别名"><a href="#五、配别名" class="headerlink" title="五、配别名"></a>五、配别名</h2><blockquote>
<p>Git 并不会在你输入部分命令时自动推断出你想要的命令,如果不想每次都输入完整的 Git 命令,可以通过 git config 文件来轻松为每一个命令设置一个别名</p>
<p>此处运行后将会写入你的配置文件,可以进入配置文件直接删除</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config --global alias.自定义命令 <span class="token string">" <span class="token variable"><span class="token variable">`</span><span class="token function">git</span><span class="token variable">`</span></span> 命令后面的指令 "</span>
<span class="token comment">#如配置查看分支信息 "git log --oneline --decorate --graph --all"</span>
<span class="token function">git</span> config --global alias.logbranch <span class="token string">"log --oneline --decorate --graph --all"</span>
<span class="token comment">#配置切换分支</span>
<span class="token function">git</span> config --global alias.co checkout
<span class="token comment">#使用方式</span>
<span class="token function">git</span> logbranch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="六、分支"><a href="#六、分支" class="headerlink" title="六、分支"></a>六、分支</h2><blockquote>
<ol>
<li><p>前言:</p>
<p>几乎所有的版本控制系统都以某种形式支持分支.使用分支意味着你可以把你的工作从开发主线上分离开来,以免影响开发主线.在很多版本控制系统中,这是略微低效的过程–常常需要完全创建一个源代码目录的副本,对于大项目来说,这会耗费很多时间,而 Git 的分支模型极其的高校轻量,是 Git 的必杀特性,也正因为这一特性,是的 Git 从众多版本控制系统中脱颖而出</p>
</li>
<li><p>分支的本质:</p>
<p><code>Git的分支,其实本质上是提交对象</code>,,所有的分支都有机会被 HEAD 引用(<code>HEAD一个时刻只会指向一个分支</code>),当我们有新的提交的时候 HEAD 会携带当前持有的分支向前移动</p>
<p>Git 的默认分支名字是 master,在多次提交后,你其实已经有一个指向最后那个提交对象的 master 分支.他会在每次的提交操作中自动向前</p>
<p>注意:Git 的”master”分支并不是一个特殊分支.她就跟其他分支完全没有区别.之所以几乎每个仓库都有 master 分支,是因为<code>git init</code>命令默认创建它,并且大多数人懒得区改动它</p>
</li>
<li><p>分支的原理:</p>
<ol>
<li><p><code>.git/refs</code>目录中保存了分支及其对应的提交对象</p>
</li>
<li><p>当运行类似于<code>git branch (branchname)</code>这样的命令时,Git 会取得当前所在分支最新提交对应的 SHA-1 值,并将其加入你想要创建的任何新分支中</p>
</li>
<li><p>当你执行<code>git branch (branchname)</code>时,Git 如何知道最新提交的 SHA-1 值呢?答案是 HEAD 文件</p>
<p><code>HEAD文件</code>是一个符号引用(stmbolic reference),指向目前所在的分支.所谓符号医用,意味着它并不像普通引用那样包含一个 SHA-1 值.它时一个指向其他引用的指针</p>
</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="1、git-branch"><a href="#1、git-branch" class="headerlink" title="1、git branch"></a>1、git branch</h3><blockquote>
<ol>
<li><p>git branch(不加参数)</p>
<p>作用:<code>显示所有分支</code>信息</p>
</li>
<li><p>git branch 分支名</p>
<p>作用:<code>创建分支</code></p>
</li>
<li><p>git branch -v</p>
<p>作用:查看每一个分支最后一次提交</p>
</li>
<li><p>git branch -d(-D 强制删除) 分支名</p>
<p>作用:<code>删除分支</code>,小 d 需要你这个分支是干净的才能删除(如已合并)</p>
</li>
<li><p>git branch –merged</p>
<p>作用:查看那些分支已经合并到当前分支</p>
<p>在这个列表中的分支名字前没有*号的分支通常可以使用<code>git branch -d</code> 删除掉</p>
</li>
<li><p>git branch –no-merged</p>
<p>作用:查看所有包含未合并工作的分支</p>
<p>尝试使用<code>git branch -d</code>命令删除在这个列表中的分支时会失败,如果真的想要删除分支并丢掉哪些工作,可以使用<code>-D</code> 选项爱强制删除它</p>
</li>
<li><p>git log –oneline –decorate –graph –all</p>
<p>作用:查看所有的分支信息命令</p>
</li>
<li><p>git branch 分支名 commitHash</p>
<p>作用:新建一个分支,并且使分支指向对应的提交对象(版本穿梭<code>可以替代撤销与重置</code>)</p>
</li>
</ol>
</blockquote>
<h3 id="2、git-checkout-分支名"><a href="#2、git-checkout-分支名" class="headerlink" title="2、git checkout 分支名"></a>2、git checkout 分支名</h3><blockquote>
<p>作用:<code>切换分支</code> checkout 还有其他作用,后面会提到</p>
<p>它会动三个地方:HEAD(指针) 暂存区 工作目录</p>
</blockquote>
<blockquote>
<ol>
<li><p><code>注意</code>:分支切换会改变你工作目录中的文件,所以在切换分支时,一定要注意你的工作目录里的文件会被改变,如果时切换到一个比较旧的分支,你的工作目录会回复到该分支最后一次提交的样子,如果 Git 不能干净利落的完成这个任务,它将禁止切换分支</p>
</li>
<li><p><code>坑</code>:在切换分支时, 如果当前分支上由未暂存的修改(<code>第一次</code>) 或者 有未提交的暂存<code>(第一次</code>) 分支可以切换成功,但是这种操作可能会污染其他分支</p>
<p>ps:<code>第一次</code>–当前分支如果已经提交过一次,将不让你切换,但是第一次没有提交过,git 会帮你保存文件 但是它并不知道新增修改是属于哪个分支,所以会带回当前分支</p>
</li>
<li><p>最佳操作方式:<code>每次在切换分支前,需要提交一下当前分支(先使用status查看状态)</code></p>
</li>
</ol>
</blockquote>
<h3 id="3、git-checkout-b-“新的分支名”"><a href="#3、git-checkout-b-“新的分支名”" class="headerlink" title="3、git checkout -b “新的分支名”"></a>3、git checkout -b “新的分支名”</h3><blockquote>
<p>创建并进入该分支,类似于上面两个命令集合</p>
</blockquote>
<h3 id="4、模拟实战流程"><a href="#4、模拟实战流程" class="headerlink" title="4、模拟实战流程"></a>4、模拟实战流程</h3><blockquote>
<ol>
<li><p>需要解决主程序的的一个小 BUG,所以使用<code>git checkout -b &quot;iss_bug&quot;</code>新建分支并在这个分支进行 bug 调修</p>
</li>
<li><p>当你再<code>iss_bug</code>分支上开发到一半,这时,在主程序发现了一个紧急 BUG 需要你放下这个重要性为次要的 bug 进行修改.你老板都给你打了紧急电话,所以你需要先将写到一半的 bug 进行保存提交(<code>commit</code>提交或者储存 到暂存区,并不是提交合并到主分支,也不是 push 提交),确定 status 是干净的时候,切换回主分支,再用第一步的方法创建<code>hot_bug</code>分支(这时候<code>hit_bug</code>的版本是 master 没有进行<code>iss_bug</code>调修的版本),进行修复</p>
</li>
<li><p>当你将紧急 bug 修复后,进行提交,确定 status 干净后切换回 master 分支,进行合并:代码如下</p>
</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> checkout master
<span class="token function">git</span> merge hit_bug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="4">
<li>修改完后再查看 status(这是个好习惯,防止偶尔记忆混淆造成不必要的麻烦),再切换至普通 bug 分支<code>iss_bug</code>进行修改,成功后切换回去合并</li>
<li>如果出现冲突,去出现冲突的文件手动修改(决定保留那部分代码),再进行<code>git add</code>表示冲突解决,在进行提交</li>
</ol>
</blockquote>
<h3 id="5、合并分支"><a href="#5、合并分支" class="headerlink" title="5、合并分支"></a>5、合并分支</h3><blockquote>
<p>命令: <code>git merge branchname</code>(分支名)</p>
<p>注意:合并分支时要先切换到<code>主要分支</code>(即下面的被合并分支),在这个分支上进行合并新分支,使得这个分支进行版本更新</p>
<ol>
<li><p>快进合并–&gt;不会产生冲突</p>
<p> 指被合并分支并没有进行修改,停留在原地,只有新分支进行修改更新,更 新完成后进行合并,原版本相当于直接前进版本,称为快进合并</p>
</li>
<li><p>典型合并–&gt;有可能产生冲突</p>
<p> 指被合并分支在新分支进行开发时,本身也进行修改开发,可能会改动到同 一代码或者文件而产生重复修改</p>
</li>
<li><p>解决冲突:<code>打开冲突的文件</code> 进行修改 ,修改完成后进行:<code>add标记修改完成</code>,然后 commit 进行提交</p>
</li>
</ol>
</blockquote>
<blockquote>
<p><code>git 在pull或者合并分支</code>的时候有时会遇到一个第一段是黄色,下面文字是青色(偏蓝色)。可以不管(直接下面 3,4 步)，如果要输入解释的话就需要:</p>
<p>1.按键盘字母 i 进入 insert 模式</p>
<p>2.修改最上面那行黄色合并信息,可以不修改</p>
<p>3.按键盘左上角”Esc”</p>
<p>4.输入”:wq”,注意是冒号+wq,按回车键即可</p>
</blockquote>
<h2 id="七、存储"><a href="#七、存储" class="headerlink" title="七、存储"></a>七、存储</h2><blockquote>
<ol>
<li><p>需求背景:</p>
<p>有时,当你在项目的一部分上已经工作了一段时间后,所有东西都进入了混乱的状态,而这时你想要切换到另一个分支做一点别的事情.问题是,你不想仅仅因为过会儿回到这一点而做了一半的工作创建一次提交</p>
</li>
<li><p>解决:</p>
<p>针对这个问题的答案是 <code>git stash</code> 命令(当然,直接提交<code>commit</code>也可以,这个是用来不想生成提交对象而用)</p>
</li>
<li><p>原理:</p>
<p>git 切换分支之所以保留你的未提交的修改文件,是因为它不想你因为误操作使得之前代码报废所以会当你 status 不干净时组织你切换分支(<code>ps</code>:如果是第一次创建的文件没有追踪过,它不认识是属于那份分支将会带到你切换后的分支造成污染),</p>
<p>而你将其保存到栈上(<code>ps</code>:换句话说将这部分内容抽取到一个类似共有的栈上,你在哪个分支都能够通过命令取到),git 就知道你这个内容已经储存并不会造成切换分支使得你写的代码丢失,便不会阻止你切换分支或者切换带文件污染分支</p>
</li>
</ol>
</blockquote>
<h3 id="1、git-stash"><a href="#1、git-stash" class="headerlink" title="1、git stash"></a>1、git stash</h3><blockquote>
<p><code>git stash</code>命令会将未完成的修改保存到一个栈上,而你可以在任何时候重新应用这些改动(<code>git stash apply</code>),</p>
<p><code>注意!!!!!</code>:使用前你要先<code>git add .</code>,否则你会发现,你执行此命令后,没有追踪的部分全部消失了</p>
</blockquote>
<h3 id="2、git-stash-list"><a href="#2、git-stash-list" class="headerlink" title="2、git stash list"></a>2、git stash list</h3><blockquote>
<p>查看存储</p>
</blockquote>
<h3 id="3、git-stash-pop"><a href="#3、git-stash-pop" class="headerlink" title="3、git stash pop"></a>3、git stash pop</h3><blockquote>
<p>来应用储藏然后立即从栈上扔掉它 <code>这是最推荐的使用</code></p>
</blockquote>
<h3 id="4、git-stash-apply-stash-2"><a href="#4、git-stash-apply-stash-2" class="headerlink" title="4、git stash apply stash@{2}"></a>4、git stash apply stash@{2}</h3><blockquote>
<p>如果不指定一个储藏,git 认为指定栈顶<code>不常用</code></p>
</blockquote>
<h3 id="5、git-stash-drop-“储藏的名字”"><a href="#5、git-stash-drop-“储藏的名字”" class="headerlink" title="5、git stash drop “储藏的名字”"></a>5、git stash drop “储藏的名字”</h3><blockquote>
<p>加上要储藏的名字移除他 <code>不常用</code></p>
</blockquote>
<h3 id="6、git-stash-clear"><a href="#6、git-stash-clear" class="headerlink" title="6、git stash clear"></a>6、git stash clear</h3><blockquote>
<p>在查看存储后,运行此命令 清空 stash 栈</p>
</blockquote>
<h2 id="八、撤销与重置"><a href="#八、撤销与重置" class="headerlink" title="八、撤销与重置"></a>八、撤销与重置</h2><blockquote>
<p>特别是重置部分理解即可(用到了再去查),撤销尽量可以掌握</p>
</blockquote>
<h3 id="Ⅰ-撤销"><a href="#Ⅰ-撤销" class="headerlink" title="Ⅰ- 撤销"></a>Ⅰ- 撤销</h3><h4 id="1、git-commit-–amend"><a href="#1、git-commit-–amend" class="headerlink" title="1、git commit –amend"></a>1、git commit –amend</h4><blockquote>
<ol>
<li><p>这个命令会将暂存区中的文件提交,修订提交(<code>不是撤销而是重新提交</code>)</p>
</li>
<li><p>如果自上次提交以来你还未做任何修改(如:在上次提交后马上执行此命令),那么快照会保持不变,而你修改的只是提交信息</p>
</li>
<li><p>如果你提交后发现忘记了暂存某些需要的修改,可以像下面这样操作</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> commit -m <span class="token string">"错误的注释"</span> <span class="token comment">#或者commit了错误的修改</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token string">"文件名或者."</span>  <span class="token comment">#重新add正确的文件</span>
<span class="token function">git</span> commit --amend  <span class="token comment">#进行重新提交</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>最终你只会有一个提交 (第二次提交将会替代第一次提交)</p>
</li>
<li><p>可以修改上次提交的文件与注释</p>
</li>
</ol>
</blockquote>
<h4 id="2、git-reset"><a href="#2、git-reset" class="headerlink" title="2、git reset"></a>2、git reset</h4><blockquote>
<ol>
<li>一般我们写完代码后,是这样提交的:</li>
</ol>
<ul>
<li>git add . &#x2F;&#x2F;添加追踪所有文件</li>
<li>git commit -m “feat(前端-Git 学习详细笔记):更新撤销 commit 操作” &#x2F;&#x2F;添加 commit 提交信息</li>
</ul>
<ol start="2">
<li>但是 commit 写完提交信息后,突然想到还有一个地方代码没改到&#x2F;保存,如果放到下一个 commit 却不合适(同一个功能修改,分成两个 commit),原因详见下方的 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E2%85%A3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">版本控制工具的使用基本原则</a></li>
<li>执行此命令命令:<code>git reset --soft HEAD^</code></li>
</ol>
<ul>
<li>HEAD^的意思是上一个版本，也可以写成 HEAD~1</li>
<li>如果你进行了 2 次 commit，想都撤回，可以使用 HEAD~2</li>
<li>详见下方 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#reset%E4%B8%89%E9%83%A8%E6%9B%B2">reset 三部曲</a></li>
</ul>
<p>作用:将文件从<code>暂存区中撤回</code>到工作目录中(仅仅是撤回 commit 操作，你写的代码仍然保留)</p>
</blockquote>
<h4 id="3、git-checkout"><a href="#3、git-checkout" class="headerlink" title="3、git checkout"></a>3、git checkout</h4><blockquote>
<p>是的,你没看错,这个是切换分支的命令,但是他也能用来<code>撤销文件修改</code></p>
<p>命令:<code>git checkout --文件名</code></p>
<p>将在工作目录中对文件的修改撤销</p>
<p><code>注意</code>:这是一个危险的命令,这很重要.你对那个文件做的任何修改都会消失–你只是拷贝了另一个文件(原来版本的文件)来覆盖它.除非你确实秦楚不想要那个文件了,否则不要使用这个命令</p>
</blockquote>
<h3 id="Ⅱ-重置-reset"><a href="#Ⅱ-重置-reset" class="headerlink" title="Ⅱ - 重置 reset"></a>Ⅱ - 重置 reset</h3><blockquote>
<p>注意:<code>--hard</code>标记是<code>reset</code>命令唯一的<code>危险用法</code>,也是 Git 真正的销毁数据的几个仅有操作之一.其他任何形式的<code>reset</code>调用都可以轻松撤销,但是<code>--hard</code>选项不能,因为它强制覆盖了工作目录中的文件.</p>
<p>如在这种特殊情况:我们的 Git 数据库中的一个提交内还留有该文件的几个版本,我们可以通过<code>reflog</code>来找回它,但若是该文件还未提交,Git 仍会覆盖他导致它无法恢复</p>
</blockquote>
<h4 id="reset-三部曲"><a href="#reset-三部曲" class="headerlink" title="reset 三部曲"></a>reset 三部曲</h4><blockquote>
<p>第一部:git reset –soft HEAD~(等于之前的–amend,后面如果跟随数字,就是回退几个版本,默认 1 个)</p>
<p> 移动 HEAD (但带着分支一起移动,与 checkout 不同(它只动 HEAD)) –&gt;相当于回到你没有 [ commit ]的时候,代码仍在</p>
<p>第二部:git reset –mixed HEAD~</p>
<p> 移动 HEAD 并且动了了暂存区</p>
<p>第三部:git reset –hard HEAD~</p>
<p> 移动 HEAD 并且动了了暂存区 动了工作目录 ( 你的提交的代码也会没掉 )</p>
</blockquote>
<h3 id="Ⅲ-错误的-git-push-提交成功后如何撤销回退"><a href="#Ⅲ-错误的-git-push-提交成功后如何撤销回退" class="headerlink" title="Ⅲ - 错误的 git push 提交成功后如何撤销回退"></a>Ⅲ - 错误的 git push 提交成功后如何撤销回退</h3><blockquote>
<p>我们在使用 Git 进行版本控制时，有可能会出现这种情况。git push 后发现提交的内容不是想要的，这时候我们怎么做呢，提交上去的内容是没有删除按钮的（比如 github，或码云）。所以我们需要一些手段将提交上去内容撤销下来。</p>
<p>而要撤销,就要用到上面所学的 <code>git reset</code></p>
</blockquote>
<h4 id="1、错误场景示范"><a href="#1、错误场景示范" class="headerlink" title="1、错误场景示范"></a>1、错误场景示范</h4><blockquote>
<p>Ⅰ- 当我撰写 [ commit ] 信息没注意到,以为是对的时候直接提交 –&gt; 因为本人提交笔记时喜欢按 [ ↑ ] 找到之前的提交信息进行修改</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813153403664.png" alt="image-20210813153403664" style="zoom:67%;">

<p>Ⅱ- 此时可以看到,错误的 [ commit ] 已经提交了 (当然,适用场景不只是 commit ,也可错误代码之类的)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813155746112.png" alt="image-20210813155746112"></p>
</blockquote>
<h4 id="2、回退操作"><a href="#2、回退操作" class="headerlink" title="2、回退操作"></a>2、回退操作</h4><blockquote>
<p>咱们操作稳重一点,使用 git reset –soft HEAD~就好了(如果回退后代码也不想要,可以用<code>git stash</code>,暂存,达到代码也回退的效果)</p>
</blockquote>
<h5 id="①-git-reflog"><a href="#①-git-reflog" class="headerlink" title="① git reflog"></a>① git reflog</h5><blockquote>
<p>commits，它在 git 中扮演了一个重要角色，我们平常用的一些操作 git clone ,git commit 都会产生 commits，通俗的讲这个就是版本号，但是 git reset 并不会产生 commits（不是不会产生，而是会产生 但是都是一样的），我们可以先看看自己项目中的 commits，使用如下命令:<code>git reflog</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813154309057.png" alt="image-20210813154309057"></p>
</blockquote>
<h5 id="②-git-reset-–soft-HEAD"><a href="#②-git-reset-–soft-HEAD" class="headerlink" title="② git reset –soft HEAD~"></a>② git reset –soft HEAD~</h5><blockquote>
<p>运行此代码后,我们的 [ HEAD ] 指向了上一个 [ commits ]</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813154448889.png" alt="image-20210813154448889"></p>
</blockquote>
<h5 id="③-查看缓存"><a href="#③-查看缓存" class="headerlink" title="③ 查看缓存"></a>③ 查看缓存</h5><blockquote>
<ul>
<li><p>此时你可以用<code>stash staus</code>查看,会发现,之前提交的代码已经放回缓存区了</p>
</li>
<li><p>如果你不想要此次提交所有代码,可以使用<code>git stash</code> ,然后再去清空即可(当然,本人此处还是需要的,所以要留下)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813154839981.png" alt="image-20210813154839981"></p>
</li>
</ul>
</blockquote>
<h5 id="④-重新撰写-commit-信息"><a href="#④-重新撰写-commit-信息" class="headerlink" title="④ 重新撰写 [ commit ]信息"></a>④ 重新撰写 [ commit ]信息</h5><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813154928064.png" alt="image-20210813154928064"></p>
</blockquote>
<h5 id="⑤-强制提交"><a href="#⑤-强制提交" class="headerlink" title="⑤ 强制提交"></a>⑤ 强制提交</h5><blockquote>
<p>如果你重新撰写 [ commit ] 后马上重新 push,你会发现无法提交: 因为我们当前落后远程一个版本!</p>
<p>所以此时直接强制提交即可,就能覆盖远程提交记录</p>
<blockquote>
<p><code>git push -f</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813155049169.png" alt="image-20210813155049169"></p>
</blockquote>
<h4 id="3、成功展示"><a href="#3、成功展示" class="headerlink" title="3、成功展示"></a>3、成功展示</h4><blockquote>
<ul>
<li>在网站工作台首页能看到已经将更改后的 [ coommit ] 强制推送上来了</li>
</ul>
<p>也许你会奇怪:为啥工作台上还能看到? 其实已经删了!!!你看下方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813155614570.png" alt="image-20210813155614570"></p>
<ul>
<li>但是你查看提交记录,会发现之前错误的 commit 已经被覆盖</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813155339300.png" alt="image-20210813155339300" style="zoom:80%;">
</blockquote>
<h2 id="九、数据恢复"><a href="#九、数据恢复" class="headerlink" title="九、数据恢复"></a>九、数据恢复</h2><blockquote>
<p>在你使用 Git 的时候,你可能会意外丢失一次提交:</p>
<p>① 通常这是因为你强制删除了正在工作的分支,但是最后你却需要这个分支;② 抑或是你硬重置了一个分支,放弃了你想要的提交.</p>
<p>如果这些事情已经发生,该如何找回你的提交呢?</p>
</blockquote>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote>
<p>推荐方法最好是<code>直接看恢复</code>,上面实例时当你使用硬重置回当初未删除版本进行恢复,出现的一系列问题解决</p>
</blockquote>
<blockquote>
<ol>
<li>假设你已经提交了五次,而现在,我们将 master 分支硬重置到了第三次提交来找回当时删除的分支.但是这时候你会发现一个事情:</li>
</ol>
<p>现在顶部的两个提交已经丢失了-没有分支指向这些提交(因为你将指针移到了第三个,那么前面两个就找不到了)</p>
<ol start="2">
<li>你现在已经得到并且恢复当时第三次还存在的的提交了(<code>恢复方法在下面,恢复文件到这步,下面3、4是回到最新版本</code>)</li>
</ol>
<p>现在准备回到当初最新的版本时,你发现你进行打印竟然没有前面两次提交信息(你需要他的哈希值进行版本穿梭或者重置),你需要最新一次提交的哈希值,但是你估计想不起来了,对吗?</p>
<ol start="3">
<li><p>最方便,也是最常用的方法,是使用一个名叫<code>log reflog</code>的工具(前面高层命令提过),当你在工作时,Git 会默默记录每一次你改变的 HEAD 时它的值,每一次你提交或者改变分支,引用日志都会被刷新</p>
</li>
<li><p>如果<code>git reflog</code>显示的内容你觉得不足够多,可以执行<code>git log -g</code>,这个命令会以标准日志的格式输出引用日志</p>
</li>
</ol>
</blockquote>
<h3 id="恢复-推荐的"><a href="#恢复-推荐的" class="headerlink" title="恢复 推荐的"></a>恢复 <code>推荐的</code></h3><blockquote>
<ol>
<li><p>通过<code>git reflog</code>找到你需要的文件还未删除的版本哈希值,那个就是你丢失的提交,你可以通过创建一个新的分支指向这个提交来恢复它.</p>
<p>例如:你可以创建一个名为<code>recover-branch</code>的分支执行这个提交</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> branch recover-branch 当前需要恢复<span class="token punctuation">(</span>之前丢失的<span class="token punctuation">)</span>的提交哈希值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>现在有一个名为<code>recover-branch</code>的分支是你的<code>master</code>分支曾经指向的地方(即当时你删除该需要的文件的前的那个版本),这样你在这次提交的版本后,也能通过切换这个分支得到曾丢失的文件</p>
</li>
<li><p>这个分支功能能帮你做很多东西,善用分支,Git 最强功能</p>
</li>
</ol>
</blockquote>
<h2 id="十、打-tag"><a href="#十、打-tag" class="headerlink" title="十、打 tag"></a>十、打 tag</h2><blockquote>
<p>Git 可以给历史中的某一次提交打上标签,表示重要.比较有代表性的是人们会用这个功能来<code>标记发布节点</code>(v1.0 等等)</p>
</blockquote>
<h3 id="1、列出标签"><a href="#1、列出标签" class="headerlink" title="1、列出标签"></a>1、列出标签</h3><blockquote>
<p>命令:<code>git tag</code> 或者 <code>git tag -l &#39;v1.*&#39;</code></p>
<p> 前者列出所有,后者列出以<code>v1.</code>开头的所有</p>
</blockquote>
<h3 id="2、创建标签"><a href="#2、创建标签" class="headerlink" title="2、创建标签"></a>2、创建标签</h3><blockquote>
<p>git 使用两种主要类型的标签:轻量标签 与 附注标签</p>
</blockquote>
<h5 id="①-轻量标签"><a href="#①-轻量标签" class="headerlink" title="① 轻量标签"></a>① 轻量标签</h5><blockquote>
<p>轻量标签很像一个不会改变的的分支(他只是一个特定提交的引用),直接在提交前使用命令即可给当前分支打上标签</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> tag v1.0
<span class="token comment">#或者下面的</span>
<span class="token function">git</span> tag v1.0 提交对象哈希<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="②-附注标签"><a href="#②-附注标签" class="headerlink" title="② 附注标签"></a>② 附注标签</h5><blockquote>
<p>附注标签是存储在 Git 数据库中的一个完整对象.他们是可以被校验的,其中包含打标签者的名字、电子邮件地址、日期时间;通常<code>建议创建复制标签</code>,这样你可以拥有以上所有信息,但如果只是想用一个临时标签,或者由于某些原因不想表村那些信息,轻量标签也是可用的</p>
</blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> tag -a v1.0
<span class="token function">git</span> tag -a v1.0 提交对象哈希
<span class="token function">git</span> tag -a v1.0 提交对象哈希 -m <span class="token string">"我的注释信息"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="3、查看特定标签"><a href="#3、查看特定标签" class="headerlink" title="3、查看特定标签"></a>3、查看特定标签</h3><blockquote>
<p><code>git show</code> 可以显示任意类型的对象(git 对象 树对象 提交对象 tag 对象)</p>
<p>命令: <code>git show tagname</code></p>
</blockquote>
<h3 id="4、删除标签"><a href="#4、删除标签" class="headerlink" title="4、删除标签"></a>4、删除标签</h3><blockquote>
<ol>
<li><p>删除标签 要删除你在本地仓库上的标签,可以使用命令 <code>git tag -d &lt;tagname&gt;</code>如下:</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> tag -d v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>应该注意上述命令并不会从任何远程仓库中移出这个标签,你必须使用<code>git push &lt;tamote&gt;:refs/tags/&lt;tagname&gt;</code>来更新你的远程仓库,如下</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> push origin :refs/tags/v1.0
<span class="token comment"># origin是你配置的远程仓库地址别名,你可以直接用远程仓库地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ol>
</blockquote>
<h3 id="5、捡出标签"><a href="#5、捡出标签" class="headerlink" title="5、捡出标签"></a>5、捡出标签</h3><blockquote>
<ol>
<li><p>如果说你想查看某个标签所指向的文件版本,可以使用<code>git checkout</code>命令</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> checkout tagname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>虽然说这会使得你的仓库处于”分离 头指针(deacthed HEAD)”状态.在”分离头指针”状态下,如果你做了某些更改然后提交它们,标签不会发生变化,但你的新提交将不属于任何分支,并且将无法访问,除非访问确切的提交哈希,因此你如果需要进行更改–比如说你需要<code>修复旧版本</code>的错误–这通常需要创建一个新的分支(捡出后创建,就会默认将当前捡出的版本作为新分支的第一版本-前面分支提到过)</p>
<p>这样就可以修改到旧版本的代码(如同 vue 的尤雨溪在 vue3.x 会更新 vue1.0 版本生态)</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> checkout -b version<span class="token punctuation">(</span>新的分支<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
</blockquote>
<h1 id="Ⅱ-代码风格"><a href="#Ⅱ-代码风格" class="headerlink" title="Ⅱ-代码风格"></a>Ⅱ-代码风格</h1><h2 id="1、Eslint"><a href="#1、Eslint" class="headerlink" title="1、Eslint"></a>1、Eslint</h2><blockquote>
<p>ESlint 是一个开源的 JavaScript 代码检查工具,由红宝书作者创建</p>
<p>初衷是为了让程序员可以创建自己的检测规则.ESLint 的所有规则都被设计成可插入的</p>
<p>ESLint 使用 Node.js 编写,这样既可以有一个快速的运行环境同时也便于安装</p>
<p>此处引入概念,具体学习之后将开新的笔记</p>
</blockquote>
<h2 id="2、commit-提交规范"><a href="#2、commit-提交规范" class="headerlink" title="2、commit 提交规范"></a>2、commit 提交规范</h2><blockquote>
<ol>
<li><p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">参考自阮一峰老师的文章</a></p>
</li>
<li><p>Header</p>
</li>
</ol>
<p>Header 部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p>
<p><strong>（1）type</strong></p>
<p><code>type</code>用于说明 commit 的类别，只允许使用下面几个标识。</p>
<blockquote>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">feat：新功能（feature）。
fix<span class="token operator">/</span>to：修复bug，可以是<span class="token constant">QA</span>发现的<span class="token constant">BUG</span>，也可以是研发自己发现的<span class="token constant">BUG</span>。
fix：产生diff并自动修复此问题。适合于一次提交直接修复问题
to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix
docs：文档（documentation）。
style：格式（不影响代码运行的变动）。
refactor：重构（即不是新增功能，也不是修改bug的代码变动）。
perf：优化相关，比如提升性能、体验。
test：增加测试。
chore：构建过程或辅助工具的变动。
revert：回滚到上一个版本。
merge：代码合并。
sync：同步主线或分支的Bug。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p>
<p><strong>（2）scope</strong></p>
<p><code>scope</code>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p><strong>（3）subject</strong></p>
<p><code>subject</code>是 commit 目的的简短描述，不超过 50 个字符。</p>
<blockquote>
<ul>
<li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li>
<li>第一个字母小写</li>
<li>结尾不加句号（<code>.</code>）</li>
</ul>
</blockquote>
</blockquote>
<h1 id="Ⅲ-远程操作"><a href="#Ⅲ-远程操作" class="headerlink" title="Ⅲ-远程操作"></a>Ⅲ-远程操作</h1><blockquote>
<p>三个必须懂的概念</p>
<ol>
<li>本地分支</li>
</ol>
<p>工作目录中的分支</p>
<ol start="2">
<li>远程跟踪分支</li>
</ol>
<p>当你往远程分支<code>push</code>(还有克隆)的时候会创建远程跟踪分支</p>
<ol start="3">
<li>远程分支</li>
</ol>
<p>指保存在 git 网站上的那个远程仓库中的分支</p>
</blockquote>
<h3 id="1、团队协作流程"><a href="#1、团队协作流程" class="headerlink" title="1、团队协作流程"></a>1、团队协作流程</h3><blockquote>
<ol>
<li><p>项目经理初始化远程仓库</p>
<p>一定要初始化一个空的仓库:再 github 上操作</p>
</li>
<li><p>项目经理创建本地仓库</p>
<ol>
<li><code>git remote 别名 仓库地址</code></li>
<li><code>git --init</code>,然后将源码复制进来</li>
<li>修改用户名 修改邮箱(双账号的才需要这步)</li>
<li><code>git add</code> 和 <code>git commit</code></li>
</ol>
</li>
<li><p>项目经理推送到本地仓库到远程仓库</p>
<ol>
<li>清理 window 凭据</li>
<li><code>git push 别名 分支</code>(输入账号密码;推完之后会附带生成远程跟踪分支)</li>
</ol>
</li>
<li><p>项目邀请成员&amp;&amp;成员接受邀请</p>
<p>在 git 网站上操作</p>
</li>
<li><p>成员克隆远程仓库</p>
<p><code>git clone 仓库地址</code></p>
<p>只有在克隆的时候 本地分支 master 和 远程跟踪分支别名&#x2F;master 是有同步关系的(可以直接 pull 或者 push 后面不用加 origin)</p>
<p>原因是,每次你 push 的时候是你远程跟踪分支替换掉(同步)你的远程分支，如果你想要新分支能直接 push，需要本地分支去追踪远程追踪分支</p>
</li>
<li><p>成员做出贡献</p>
<ol>
<li>修改源代码文件</li>
<li><code>git add -&gt; commit -&gt; push</code></li>
</ol>
</li>
<li><p>项目经理更新修改</p>
<ol>
<li><code>git fetch 别名</code>(将修改同步到远程跟踪分支上)</li>
<li>git merge 远程跟踪分支</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="2、远程库"><a href="#2、远程库" class="headerlink" title="2、远程库"></a>2、远程库</h3><blockquote>
<p>正常的数据推送 和 拉取步骤</p>
<ol>
<li>确保本地分支已经跟踪了远程跟踪分支</li>
<li>拉取上传数据： git <code>pull</code> or <code>push</code></li>
</ol>
</blockquote>
<h4 id="Ⅰ-远程跟踪分支"><a href="#Ⅰ-远程跟踪分支" class="headerlink" title="Ⅰ-远程跟踪分支"></a>Ⅰ-远程跟踪分支</h4><blockquote>
<p>流程与释义:</p>
<ol>
<li><p><code>远程跟踪分支</code>是远程分支状态的引用。它们是你不能移动的本地分支。当你做任何网络通信操作时，它们会自动移动</p>
</li>
<li><p>它们以（remote）&#x2F;(branch)形式命名，如果你想要看你最后一次与远程仓库 origin 时 master 分支的状态，可以查看 origin&#x2F;master 分支</p>
</li>
<li><p>当<code>克隆</code>一个仓库时,它通常会自动的创建一个跟踪<code>origin/master</code>的 master 分支（所以你可以不跟踪直接 pull 与 push 后面不跟 origin）</p>
</li>
<li><p>当我克隆之后，别人新建了一个分支 push 上去，我这时候想要或者并且跟踪这个新分支，我需要先<code>git fetch origin</code>获取下来，获取下来后想要切换并且跟踪这个分支时使用命令<code>git checkout --track 远程跟踪分支名(origin/分支名)</code></p>
</li>
</ol>
</blockquote>
<h5 id="做跟踪"><a href="#做跟踪" class="headerlink" title="做跟踪"></a>做跟踪</h5><blockquote>
<ol>
<li><p>克隆仓库时,会自动为 master 做跟踪</p>
</li>
<li><p>本地没有分支,要新建分支且追踪</p>
</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> checkout --track 远程跟踪分支<span class="token punctuation">(</span>remote/分支名<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>本地已经创建了分支,</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> branch -u 远程跟踪分支<span class="token punctuation">(</span>remote/分支名<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<h4 id="Ⅱ-本地分支怎么跟踪远程跟踪分支"><a href="#Ⅱ-本地分支怎么跟踪远程跟踪分支" class="headerlink" title="Ⅱ-本地分支怎么跟踪远程跟踪分支"></a>Ⅱ-本地分支怎么跟踪远程跟踪分支</h4><blockquote>
<ol>
<li><p>当克隆的时候 会自动生成一个 master 本地分支（已经跟踪了对应的远程跟踪分支）</p>
</li>
<li><p>在新建其他分支时，可以指定想要跟踪的远程跟踪分支</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> checkout -b 本地分支名 远程跟踪分支名
<span class="token comment">#简写形式</span>
<span class="token function">git</span> checkout --track 远程跟踪分支名<span class="token punctuation">(</span>origin/分支名<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>将一个已经存在的本地分支 改成 一个跟踪分支</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> branch -u 远程跟踪分支名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
</blockquote>
<h4 id="Ⅲ-冲突"><a href="#Ⅲ-冲突" class="headerlink" title="Ⅲ-冲突"></a>Ⅲ-冲突</h4><blockquote>
<ol>
<li>git 本地操作会不会有冲突？</li>
</ol>
<p>典型合并的时候（如新建分支合并时）</p>
<ol start="2">
<li>git 远程协作的时候会不会有冲突</li>
</ol>
<p><code>push</code>与<code>pull</code></p>
</blockquote>
<blockquote>
<p>解决流程：</p>
<ol>
<li><p>假设你修改了 a.js 的代码，已经<code>add &amp;&amp;commit</code>（必须先这样才能提交，才能触发冲突）</p>
</li>
<li><p>但是这时别人也改了 a.js 同一行代码并且已经 push 上去了，你这时候进行 push 将会报错</p>
</li>
<li><p>这时候你需要先将其 pull 下来，这时候你会发现你的 git 将会给你提示，并且在本地的 a.js 中文件代码中，保留了你们两个的代码（并且会给你标注出来）</p>
</li>
<li><p>这时候一定要去与<code>与你冲突的开发人员交流</code>,讨论保留哪一个人的代码，或者进行修改（直接在你 pull 后的本地目录中修改），修改完成后使用<code>git add .</code>标记解决冲突然后<code>push</code>提交，这样别人 pull 的时候 git 就知道这部分时保留哪部分代码，直接覆盖（即在一个地方更改然后标记提交即可）</p>
</li>
<li><p>如果你发生冲突<code>不进行沟通</code>，将别人代码<code>直接注释掉</code>，让自己代码能跑，那么–真的很爽</p>
</li>
</ol>
<p>但是别人功能可能就炸了，这时候你会被暴打:smirk:</p>
<p>因为你解决冲突后（git add .）别人 pull 的时候并不会提示冲突，因为你用<code>add</code>标记解决了冲突，git 认出来后会直接默认<code>覆盖</code>他的代码，不知不觉，你可能就毁了另外一个程序员美好的一天（莫名其妙的 BUG 导致加班），如果他没反应过来，可能就是两天甚至…，你到时候住院的时间也与这个成正比:smirk:</p>
</blockquote>
<h4 id="Ⅳ-pull-request-流程"><a href="#Ⅳ-pull-request-流程" class="headerlink" title="Ⅳ- pull request 流程"></a>Ⅳ- pull request 流程</h4><blockquote>
<p> <code>如果你想要参加某个项目，但是并没有推送权限</code>，这时候可以对这个项目进行”派生“（<code>Fork</code>),派生是指 GitHub 将在你的空间创建一个完全属于你的项目副本,且你对其有推送权限.通过这种方式,项目的管理者不再需要忙着把用户添加到贡献者列表并给予它们推送权限.人们可以派生这个项目,将修改推送到派生出的项目副本中,并通过创建合并请求(pull request)让它们改动进入原版本库</p>
<p>基本流程:</p>
<ol>
<li>自己在 git 网站上 fork 的项目到自己空间中,下面的操作都是基于这个 fork 的项目</li>
<li>从 master 分支中创建一个新的分支</li>
<li>提交一些修改来改进项目</li>
<li>将这个分支推送到 git 上</li>
<li>创建一个<code>合并</code>请求(在网站上点击发送信息)</li>
<li>在网站上进行讨论,并且根据实际情况继续修改</li>
<li>项目的拥有者合并或者关闭你的合并请求</li>
</ol>
<p>注意:</p>
<p>每次在发起新的<code>Pull Request</code>时 要去拉去最新的原仓库的代码 而不是自己 fork 的那个仓库</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git remote add &lt;源仓库名字（自己定义）&gt; &lt;仓库地址链接&gt;
git fetch 远程仓库名字
git merge 对应的远程跟踪分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</blockquote>
<hr>
<h1 id="Ⅳ-版本控制工具的使用基本原则"><a href="#Ⅳ-版本控制工具的使用基本原则" class="headerlink" title="Ⅳ-版本控制工具的使用基本原则"></a>Ⅳ-版本控制工具的使用基本原则</h1><h2 id="1、精准的提交"><a href="#1、精准的提交" class="headerlink" title="1、精准的提交"></a>1、精准的提交</h2><p>每次提交都是一个小儿完整的功能或者一个 BUG 的修复。不应该出现多个功能点一块提交或者多个 BUG 一起修复的情况。如果一旦发现提交的代码有问题，可以方便的会滚到改动之前的正确状态，不会影响到其他协作者开发进程。</p>
<h2 id="2、频繁的提交"><a href="#2、频繁的提交" class="headerlink" title="2、频繁的提交"></a>2、频繁的提交</h2><p>尽可能频繁的提交你的改动到远程仓库，这样，可以避免将来合并代码的时候产生大量的冲突以至于难以解决。同时，也可以让其他同事比较快的共享你的改动。</p>
<h2 id="3、不要提交不完整的功能"><a href="#3、不要提交不完整的功能" class="headerlink" title="3、不要提交不完整的功能"></a>3、不要提交不完整的功能</h2><p>如果你正在开发的新功能比较庞大，那么可以讲这个功能尽可能拆分为几个逻辑模块，并且要保证分次提交的逻辑模块不会影响到整个系统的正确性。如果你只是因为临时的一些事情需要切到别的分支或者是临时需要中断开发（比如说下班）,那么应该使用<code>Stash</code>储藏功能来保存你的更改。 –&gt;<a href="#%E4%B8%83%E3%80%81%E5%AD%98%E5%82%A8">相关知识点部分我跳转</a></p>
<h2 id="4、提交前进行测试"><a href="#4、提交前进行测试" class="headerlink" title="4、提交前进行测试"></a>4、提交前进行测试</h2><p>不要想当然的认为自己的代码是正确的，提交之前应该经过充分的测试才能提交，即使是提交到本地仓库，也应该进行测试，因为这些代码在未来会被推送到远程共享给你的同事。</p>
<h2 id="5、高质量的提交注释"><a href="#5、高质量的提交注释" class="headerlink" title="5、高质量的提交注释"></a>5、高质量的提交注释</h2><p>每次提交都应该包含完整的注释。团队成员应当遵循统一的提交规则，一般应当明确的体现出提交的类型以及具体的事情，例如 feat: add message list;</p>
<h2 id="6、遵循统一的流程规范"><a href="#6、遵循统一的流程规范" class="headerlink" title="6、遵循统一的流程规范"></a>6、遵循统一的流程规范</h2><p>Git 可以支持很多不同的工作流程：长期分支、功能分支、合并以及 rebase、git-flow 等等。选择什么样的开发流程要取决如下一些因素：项目开发的类型，部署模式和（可能是最重要的）开发团队成员的个人习惯。不管怎样，选择什么样的流程都需要得到所有开发成员的一致认可，并且一直遵循它。</p>
<h1 id="Ⅴ-实际遇到的问题与解决-Mark"><a href="#Ⅴ-实际遇到的问题与解决-Mark" class="headerlink" title="Ⅴ- 实际遇到的问题与解决 Mark"></a>Ⅴ- 实际遇到的问题与解决 Mark</h1><h2 id="1、将本地已有的一个项目上传到新建的-git-仓库的方法"><a href="#1、将本地已有的一个项目上传到新建的-git-仓库的方法" class="headerlink" title="1、将本地已有的一个项目上传到新建的 git 仓库的方法"></a>1、将本地已有的一个项目上传到新建的 git 仓库的方法</h2><p>将本地已有的一个非 git 项目上传到新建的 git 仓库的方法一共有两种。</p>
<h3 id="Ⅰ-克隆-拷贝"><a href="#Ⅰ-克隆-拷贝" class="headerlink" title="Ⅰ- 克隆+拷贝"></a>Ⅰ- 克隆+拷贝</h3><blockquote>
<p>第一种方法比较简单，直接用把远程仓库拉到本地，然后再把自己本地的项目拷贝到仓库中去。然后 push 到远程仓库上去即可。<strong>此方法适用于本地项目不是一个 git 仓库的情况。</strong></p>
<p>具体步骤如下：</p>
<h4 id="1、首先克隆"><a href="#1、首先克隆" class="headerlink" title="1、首先克隆"></a>1、首先克隆</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone git@github.com:yuanmingchen/tensorflow_study.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="2、然后复制自己项目的所有文件-除了-git文件-到刚刚克隆下来的仓库中"><a href="#2、然后复制自己项目的所有文件-除了-git文件-到刚刚克隆下来的仓库中" class="headerlink" title="2、然后复制自己项目的所有文件(除了.git文件)到刚刚克隆下来的仓库中"></a>2、然后复制自己项目的所有文件(除了<code>.git</code>文件)到刚刚克隆下来的仓库中</h4><h4 id="3、最后-push-到远程仓库上面去"><a href="#3、最后-push-到远程仓库上面去" class="headerlink" title="3、最后 push 到远程仓库上面去"></a>3、最后 push 到远程仓库上面去</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<h3 id="Ⅱ-强行合并两个仓库"><a href="#Ⅱ-强行合并两个仓库" class="headerlink" title="Ⅱ- 强行合并两个仓库"></a>Ⅱ- 强行合并两个仓库</h3><blockquote>
<p>第二种方法就是先将本地的项目初始化为一个 git 仓库，然后再强行合并本地仓库和远程仓库，由于这两个仓库是完全不同的两个仓库，所以直接 pull 都会报错，需要在 pull 的时候假加上–allow-unrelated-histories 才可以 pull 成功。<strong>此方法适用于本地项目已经是一个 git 仓库的情况。</strong></p>
<p>具体步骤如下：</p>
<h4 id="1、新建-git-仓库，将本地项目设置为一个-git-仓库。如果本地项目已经是一个-git-仓库了，请跳过这一步。在项目根目录下"><a href="#1、新建-git-仓库，将本地项目设置为一个-git-仓库。如果本地项目已经是一个-git-仓库了，请跳过这一步。在项目根目录下" class="headerlink" title="1、新建 git 仓库，将本地项目设置为一个 git 仓库。如果本地项目已经是一个 git 仓库了，请跳过这一步。在项目根目录下"></a>1、新建 git 仓库，将本地项目设置为一个 git 仓库。如果本地项目已经是一个 git 仓库了，请跳过这一步。在项目根目录下</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="2、把当前目录下的已有文件-除了-git文件-全部加到刚刚新建的-git-仓库中"><a href="#2、把当前目录下的已有文件-除了-git文件-全部加到刚刚新建的-git-仓库中" class="headerlink" title="2、把当前目录下的已有文件(除了.git文件)全部加到刚刚新建的 git 仓库中"></a>2、把当前目录下的已有文件(除了<code>.git</code>文件)全部加到刚刚新建的 git 仓库中</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="3、保存刚刚加入的文件，并书写保存信息"><a href="#3、保存刚刚加入的文件，并书写保存信息" class="headerlink" title="3、保存刚刚加入的文件，并书写保存信息"></a>3、保存刚刚加入的文件，并书写保存信息</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">"push current files"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="4、将本地仓库与远程仓库关联起来"><a href="#4、将本地仓库与远程仓库关联起来" class="headerlink" title="4、将本地仓库与远程仓库关联起来"></a>4、将本地仓库与远程仓库关联起来</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:yuanmingchen/tensorflow_study.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="5、pull-远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories-忽略本地仓库和远程仓库的无关性，强行合并（关键）"><a href="#5、pull-远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories-忽略本地仓库和远程仓库的无关性，强行合并（关键）" class="headerlink" title="5、pull 远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories 忽略本地仓库和远程仓库的无关性，强行合并（关键）"></a>5、pull 远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories 忽略本地仓库和远程仓库的无关性，强行合并（关键）</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> pull origin master --allow-unrelated-histories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="6、把本地仓库的内容-push-到远程仓库"><a href="#6、把本地仓库的内容-push-到远程仓库" class="headerlink" title="6、把本地仓库的内容 push 到远程仓库"></a>6、把本地仓库的内容 push 到远程仓库</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后就 ok 了。</p>
</blockquote>
<h3 id="Ⅲ-其他-git-命令"><a href="#Ⅲ-其他-git-命令" class="headerlink" title="Ⅲ- 其他 git 命令"></a>Ⅲ- 其他 git 命令</h3><blockquote>
<p>最后附上 git 的一些其他命令：<br>1、删除已将关联的远程主机</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">rm</span> origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2、查看所有本地分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3、新建一个分支，名字叫 xf</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> branch xf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>4、切换分支到 xf 分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> checkout xf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>5、把远程分支的代码 pull 到本地分支：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;<br>如：取回 origin 主机的 master 分支，与本地的 xf 分支合并，输入命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> pull origin master:xf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>6、推送当前的分支，git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;<br>PS:注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以 git pull 是&lt;远程分支&gt;:&lt;本地分支&gt;，而 git push 是&lt;本地分支&gt;:&lt;远程分支&gt;。<br>如：把本地的 xf 分支推送到 origin 主机的 master 分支，输入命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push origin xf:master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<h2 id="2、解决同一台电脑生成两份或多份-ssh-密钥、公钥映射两个或多个-GitHub-账号"><a href="#2、解决同一台电脑生成两份或多份-ssh-密钥、公钥映射两个或多个-GitHub-账号" class="headerlink" title="2、解决同一台电脑生成两份或多份 ssh 密钥、公钥映射两个或多个 GitHub 账号"></a>2、解决同一台电脑生成两份或多份 ssh 密钥、公钥映射两个或多个 GitHub 账号</h2><blockquote>
<p>此解决方案由百度多个方案结合而来,截取对我有用部分</p>
</blockquote>
<h3 id="Ⅰ-需求分析"><a href="#Ⅰ-需求分析" class="headerlink" title="Ⅰ- 需求分析"></a>Ⅰ- 需求分析</h3><blockquote>
<p>本人注册一个 GitHub 账户，用来分享本人自己的开源项目或者代码，同时，公司注册了一个 GitHub 账户，用来分享公司的开源项目。如果按照单个 ssh 公钥生成的方法则会把之前的公钥覆盖掉，这样将导致其中一方在下一次上传代码，本机和 GitHub 无法映射成功。</p>
<p>解决这个问题首先要明确如何生成单个 ssh 公钥。<br>ssh 生成单个公钥命令：<code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>。<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成 ssh 公钥</a><br>上述命令会在当前<code>~/.ssh</code>目录下生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件。其中<code>id_rsa</code>是私钥文件，<code>id_rsa_.pub</code>是公钥文件。<br><code>id_rsa</code>和<code>id_rsa_.pub</code>文件都是通过一个邮箱号生成的，同一个公钥文件不可以配置两个不同 GitHub 账户（已测试）。<br>那么两个 GitHub 账户就需要两个不同的邮箱号，来生成两组不同的公钥文件。</p>
</blockquote>
<h3 id="Ⅱ-解决方案思路"><a href="#Ⅱ-解决方案思路" class="headerlink" title="Ⅱ- 解决方案思路"></a>Ⅱ- 解决方案思路</h3><blockquote>
<p>命令：<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -f ~/.ssh/id_rsa_example</code><br>示例：分别以<a href="mailto:&#55;&#x39;&#x31;&#x38;&#x31;&#53;&#53;&#54;&#55;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;">&#55;&#x39;&#x31;&#x38;&#x31;&#53;&#53;&#54;&#55;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;</a>和<a href="mailto:&#x67;&#x61;&#108;&#x61;&#x78;&#x79;&#x73;&#111;&#102;&#x74;&#64;&#x73;&#x69;&#110;&#x61;&#x2e;&#99;&#x6e;">&#x67;&#x61;&#108;&#x61;&#x78;&#x79;&#x73;&#111;&#102;&#x74;&#64;&#x73;&#x69;&#110;&#x61;&#x2e;&#99;&#x6e;</a>两个邮箱在<code>~/.ssh</code>目录下生成两级不同的公钥文件。<br><a href="mailto:&#55;&#x39;&#x31;&#x38;&#49;&#x35;&#x35;&#54;&#55;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#55;&#x39;&#x31;&#x38;&#49;&#x35;&#x35;&#54;&#55;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>邮箱：<code>ssh-keygen -t rsa -C &quot;791815567@qq.com&quot; -f ~/.ssh/id_rsa_me</code> &gt;<a href="mailto:&#x67;&#97;&#108;&#97;&#120;&#121;&#115;&#111;&#x66;&#x74;&#x40;&#x73;&#x69;&#x6e;&#97;&#46;&#99;&#x6e;">&#x67;&#97;&#108;&#97;&#120;&#121;&#115;&#111;&#x66;&#x74;&#x40;&#x73;&#x69;&#x6e;&#97;&#46;&#99;&#x6e;</a>邮箱：<code>ssh-keygen -t rsa -C &quot;galaxysoft@sina.cn&quot; -f ~/.ssh/id_rsa_galaxysoft</code><br>生成过程可参考<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成单个 ssh 公钥</a> 这篇文章。<br>执行完成后，会以<code>~/.ssh</code>目录下看<a href="mailto:&#x37;&#x39;&#x31;&#x38;&#x31;&#x35;&#53;&#x36;&#x37;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#x37;&#x39;&#x31;&#x38;&#x31;&#x35;&#53;&#x36;&#x37;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;</a>邮箱对应的私钥文件<code>id_rsa_me</code>、公钥文件<code>id_rsa_me.pub</code>和<a href="mailto:&#x67;&#97;&#108;&#x61;&#120;&#x79;&#115;&#111;&#x66;&#x74;&#x40;&#x73;&#105;&#110;&#97;&#46;&#99;&#x6e;">&#x67;&#97;&#108;&#x61;&#120;&#x79;&#115;&#111;&#x66;&#x74;&#x40;&#x73;&#105;&#110;&#97;&#46;&#99;&#x6e;</a>邮箱对应的私钥文件<code>id_rsa_galaxysoft</code>、公钥文件<code>id_rsa_galaxysoft.pub</code><br>分别在两个 GitHub 账户中添加对应的公钥信息即可，可参考<a href="https://blog.csdn.net/mynameissls/article/details/50528048">如何生成单个 ssh 公钥</a> 这篇文章</p>
</blockquote>
<h3 id="Ⅲ-生成新-ssh-key"><a href="#Ⅲ-生成新-ssh-key" class="headerlink" title="Ⅲ- 生成新 ssh key"></a>Ⅲ- 生成新 ssh key</h3><blockquote>
<p>如果我们电脑上已经存在了一个 ssh key，那么我们需要在我们电脑上生成第二个你想在本电脑上使用的 id_rsa，使用命令：<code>ssh-keygen -t rsa -C &quot;你的github注册邮箱&quot;</code>。</p>
<p>下图红色标注部分会提示你把新生成的 id_rsa 存放到哪里，此处默认会存放在 c 盘的用户名下的.ssh 文件夹下（即你第一个 github 用户 ssh key 存放的目录），因此我们需要输入路径&#x2F;c&#x2F;Users&#x2F;DodoMonster&#x2F;.ssh（注意此路径是你的系统盘下用户目录安放 ssh 密钥的目录，请使用自己电脑上相对应的目录），最后我以“id_rsa_me”重新命名了 ssh key 防止默认与已有的 ssh key 重复。</p>
<blockquote>
<p>在输入了路径后，会提示你输入提交项目时输入的验证密码，不输则表示不用密码，这是为了防止别人随便在你的项目上 push 东西，所以最好还是输入以下你的密码。回车，再重复输入确认回车即可。</p>
</blockquote>
</blockquote>
<h3 id="Ⅳ-添加新-ssh-key"><a href="#Ⅳ-添加新-ssh-key" class="headerlink" title="Ⅳ- 添加新 ssh key"></a>Ⅳ- 添加新 ssh key</h3><blockquote>
<p>默认 SSH 只会读取 id_rsa，所以为了让 SSH 识别新的私钥，需要将其添加到 SSH agent<br>使用命令：<code>ssh-add ~/.ssh/id_rsa_me</code>(后面的是自己取的名字)</p>
<p>如果报错：Could not open a connection to your authentication agent.无法连接到 ssh agent<br>可执行<code>ssh-agent bash</code>命令后再执行<code>ssh-add</code>命</p>
<p>然后将公钥添加到 git 账号中 <a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p>
</blockquote>
<h3 id="Ⅴ-配置-config-文件"><a href="#Ⅴ-配置-config-文件" class="headerlink" title="Ⅴ- 配置 config 文件"></a>Ⅴ- 配置 config 文件</h3><blockquote>
<p>查看.ssh 文件中是否存在 config 文件</p>
<p>如果已存在则直接编辑 config 文件，命令：<code>vim config</code> #这是 linux 的命令，进入了 vim 界面后按<code>a或i或A或I</code>进入编辑模式，编辑完成后按 esc 键输入<code>:wq</code> 保存文件退出</p>
<p>如果不存在则需要创建 config 文件，命令：<code>touch config</code>，再对 config 文件进行编辑</p>
<p>对 config 文件进行配置填写：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Default 第一个账号(123456@xxxx.com)</span>

Host gsgit
    HostName gitee.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa_me


<span class="token comment">#second 第二个账号（38894403@xxxx.com）</span>

Host mygit
     HostName gitee.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>其中 Host 后的名字可以随意方便自己记忆，但 HostName 必须为<code>github.com(或者其它git地址)。</code></p>
</blockquote>
</blockquote>
<h3 id="Ⅵ-测试是否配置成功"><a href="#Ⅵ-测试是否配置成功" class="headerlink" title="Ⅵ- 测试是否配置成功"></a>Ⅵ- 测试是否配置成功</h3><blockquote>
<p>使用命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> -T git@zc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>出现欢迎语则为配置成功。</p>
<p>注意：配置完成后，在连接 Host 不是 github.com 的 github 仓库时，远程库的地址要对应地做一些修改：</p>
<p>而并非原来的<a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#111;&#x6d;</a></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> clone git@gitee.com:hongjilin/cx.git
//改为
<span class="token function">git</span> clone git@mygit:hongjilin/cx.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这样每次连接都会使用 id_rsa_me 与服务器进行连接。</p>
<p>配置至此，大功告成！</p>
</blockquote>
<h3 id="Ⅶ-问题-Mark"><a href="#Ⅶ-问题-Mark" class="headerlink" title="Ⅶ- 问题 Mark"></a>Ⅶ- 问题 Mark</h3><blockquote>
<p>当我切换到另外一个账号提交时 commit 的提交者仍寻找全局配置中的 username 作为签名 而不是当前本地库绑定提交账号的用户名(所以我用公司账号的<code>.ssh</code>配置绕过了组织检测,但是署名却用的是个人账户)</p>
<p>别小看这个 BUG,挺恐怖的,下面举个我的栗子:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210621172453710.png" alt="image-20210621172453710"></p>
<p>到这时候你可能觉得好像也没啥吧?但是我个人账号不是公司组织里面的(也不好解释)、计算公司个人绩效时也无法统计、之前版本还无法用搜索条件查找我个人账号(因为本身个人账号就不是组织里面的)的提交…..问题可大可小</p>
<p>所以此处<code>Mark</code>,留待后续学习生活解决</p>
</blockquote>
<h4 id="此问题解决"><a href="#此问题解决" class="headerlink" title="此问题解决"></a>此问题解决</h4><blockquote>
<p>之前只是将此问题 Mark,但是未将解决方式具体写下,现将其更新</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210621171934972.png" alt="image-20210621171934972"></p>
<p>或者可以直接写个 python 小脚本来修改:如果根据该仓库 clone 时的账号来进行切换是否更合理,这是个好办法…</p>
</blockquote>
<h2 id="3、commit-报错无法提交"><a href="#3、commit-报错无法提交" class="headerlink" title="3、commit 报错无法提交"></a>3、commit 报错无法提交</h2><blockquote>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token operator">></span> running pre-commit hook: lint-staged
<span class="token punctuation">[</span>STARTED<span class="token punctuation">]</span> Preparing<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>FAILED<span class="token punctuation">]</span> warning: LF will be replaced by CRLF <span class="token keyword">in</span> sh.exe.stackdump.
<span class="token punctuation">[</span>FAILED<span class="token punctuation">]</span> The <span class="token function">file</span> will have its original line endings <span class="token keyword">in</span> your working directory.
<span class="token punctuation">[</span>STARTED<span class="token punctuation">]</span> Running tasks<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>SKIPPED<span class="token punctuation">]</span> Skipped because of previous <span class="token function">git</span> error.
<span class="token punctuation">[</span>STARTED<span class="token punctuation">]</span> Applying modifications<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>SKIPPED<span class="token punctuation">]</span>
<span class="token punctuation">[</span>SKIPPED<span class="token punctuation">]</span>   × lint-staged failed due to a <span class="token function">git</span> error.

 × lint-staged failed due to a <span class="token function">git</span> error.
<span class="token punctuation">[</span>STARTED<span class="token punctuation">]</span> Cleaning up<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>SKIPPED<span class="token punctuation">]</span>   × lint-staged failed due to a <span class="token function">git</span> error.
 Any lost modifications can be restored from a <span class="token function">git</span> stash:


pre-commit hook failed <span class="token punctuation">(</span>add --no-verify to bypass<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>解决方式</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">执行npm run lint， 根据提示修改错误（推荐）
<span class="token function">git</span> commit -m <span class="token string">""</span> --no-verify 绕过了lint的检查<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</blockquote>
<h2 id="4、Git-提交时出现-合并提示-Merge-branch-39-master-39-of-之解决方法"><a href="#4、Git-提交时出现-合并提示-Merge-branch-39-master-39-of-之解决方法" class="headerlink" title="4、Git 提交时出现(合并提示)Merge branch &#39;master&#39; of ...之解决方法"></a>4、Git 提交时出现(<code>合并提示</code>)<code>Merge branch &#39;master&#39; of ...</code>之解决方法</h2><blockquote>
<p>多人协作开发项目，在上传代码时通常会先 pull 一下远程代码，使本地与远程同步更新，但是如果远程此时与自己代码存在冲突，在解决冲突后提交有时会出现“Merge branch ‘master’ of …”这条信息。这是因为 pull 其本质是 fetch+Merge 的结合。通常会分为以下两种情况：</p>
<p>1.如果远程分支超前于本地分支，并且本地也没有 commit 操作，此时 pull 会采用’fast-forward’模式，该模式不会产生合并节点，也即不产生”Merge branch ‘master’ of …”信息。</p>
<p>2.如果本地有 commit 提交，此时若存在冲突，pull 拉取代码时远程和本地会出现分叉，会进行分支合并，就会产生”Merge branch ‘master’ of …”信息。</p>
<p><strong>解决方法</strong></p>
<blockquote>
<p>使用<code>git pull --rebase</code>命令，如果没有冲突,则会直接合并，如果存在冲突，手动解决冲突即可，不会再产生那条多余的信息。如果你不想每次都 rebase，可以在 git bash 里执行</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config --global pull.rebase <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个配置就是告诉 git 在每次 pull 前先进行 rebase 操作。</p>
</blockquote>
</blockquote>
<h3 id="①-可能出现的相关报错error-Cannot-pull-with-rebase"><a href="#①-可能出现的相关报错error-Cannot-pull-with-rebase" class="headerlink" title="① 可能出现的相关报错error:Cannot pull with rebase"></a>① 可能出现的相关报错<code>error:Cannot pull with rebase</code></h3><blockquote>
<ol>
<li>git 执行<code>git pull –rebase</code>后报错误如下：</li>
</ol>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">error: cannot pull with rebase: Your index contains uncommitted changes.
error: please commit or stash them.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ol start="2">
<li><p>原因：如果有未提交的更改，是不能 git pull 的</p>
</li>
<li><p>解决：</p>
</li>
</ol>
<ul>
<li>先执行<code>git stash</code> –&gt;#可用来暂存当前正在进行的工作</li>
<li>再执行<code>git pull –-rebase</code></li>
<li>最后再执行<code>git stash pop</code> –&gt;#从 Git 栈中读取最近一次保存的内容</li>
</ul>
<ol start="4">
<li>截图示例</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210705115521085.png" alt="image-20210705115521085"></p>
</blockquote>
<h3 id="②-防止冲突的有效操作"><a href="#②-防止冲突的有效操作" class="headerlink" title="② 防止冲突的有效操作"></a>② <em>防止冲突的有效操作</em></h3><blockquote>
<p>不要直接用<code>git pull</code>拉取,而是分开操作,先拉取代码(拉取后可以先查看冲突部分取解决).随后再去合并</p>
<ol>
<li><code>git fetch 别名</code>(将修改同步到远程跟踪分支上)</li>
<li>git merge 远程跟踪分支</li>
</ol>
</blockquote>
<h2 id="5、Git-删除误提交的大文件历史记录"><a href="#5、Git-删除误提交的大文件历史记录" class="headerlink" title="5、Git 删除误提交的大文件历史记录"></a>5、Git 删除误提交的大文件历史记录</h2><blockquote>
<ol>
<li>应用场景:在我们日常使用 Git 的时候，一般比较小的项目，我们可能不会注意到.git 这个文件。其实.git 文件主要用来记录每次提交的变动，当我们的项目越来越大的时候，我们发现.git 文件越来越大。很大的可能是因为提交了大文件，如果你提交了大文件，那么即使你在之后的版本中将其删除，但是<code>实际上记录中的大文件仍然存在</code>。</li>
<li>原因分析:为什么呢？仔细想一想，虽然你在后面的版本中删除了大文件，但是 Git 是有版本倒退功能的吧，那么如果大文件不记录下来，git 拿什么来给你回退呢？</li>
<li>导致的问题:.git 文件越来越大导致的问题是–每次拉项目都要耗费大量的时间，并且每个人都要花费那么多的时间。</li>
<li>git 给出了解决方案，使用 git branch-filter 来遍历 git history tree, 可以永久删除 history 中的大文件，达到让.git 文件瘦身的目的。</li>
</ol>
<p>下面给出步骤（以下步骤非常危险，<code>操作需谨慎!</code>,最好最好不要在公司项目中使用）</p>
</blockquote>
<h3 id="Ⅰ-列出仓库中最大的几个对象及其文件名"><a href="#Ⅰ-列出仓库中最大的几个对象及其文件名" class="headerlink" title="Ⅰ-列出仓库中最大的几个对象及其文件名"></a>Ⅰ-列出仓库中最大的几个对象及其文件名</h3><blockquote>
<p>列出所有仓库中的对象（包括 SHA 值、大小、路径等），并按照大小降序排列，列出 TOP 5(本人示例,你也可多展示)</p>
<ol>
<li>命令示例</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> rev-list --all --objects <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">git</span> verify-pack -v .git/objects/pack/*.idx <span class="token operator">|</span> <span class="token function">sort</span> -k <span class="token number">3</span> -n <span class="token operator">|</span> <span class="token function">tail</span> -n <span class="token number">5</span> <span class="token operator">|</span> <span class="token function">awk</span> -F <span class="token string">' '</span>  <span class="token string">'&#123;print $1&#125;'</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>图示</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%97%E5%87%BA%E4%BB%93%E5%BA%93%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%87%E4%BB%B6%E5%90%8D.png" alt="image-20210508171542001"></p>
</blockquote>
<h3 id="Ⅱ-将某文件从历史记录中删除"><a href="#Ⅱ-将某文件从历史记录中删除" class="headerlink" title="Ⅱ-将某文件从历史记录中删除"></a>Ⅱ-将某文件从历史记录中删除</h3><blockquote>
<p>既然文件找到了(此处删除<code>杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg</code>)，那么得将该文件从历史记录中删除，执行以下命令：</p>
<ol>
<li>命令示例:</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline --branches -- <span class="token string">"杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>图示</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210508171916951.png" alt="image-20210508171916951"></p>
</blockquote>
<h3 id="Ⅲ-重写所有-commit，将该文件从-Git-历史中完全删除"><a href="#Ⅲ-重写所有-commit，将该文件从-Git-历史中完全删除" class="headerlink" title="Ⅲ-重写所有 commit，将该文件从 Git 历史中完全删除"></a>Ⅲ-重写所有 commit，将该文件从 Git 历史中完全删除</h3><blockquote>
<p>上面的命令执行后只是从历史记录中移除，还没有完全删除它，我们需要重写所有 commit，将该文件从 Git 历史中完全删除：</p>
<ol>
<li>代码示例:</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> filter-branch --index-filter <span class="token string">'git rm --cached --ignore-unmatch  "杂记_其他(如破解与配置)的碎片化笔记/Typora笔记软件分享/tools/软件包/Typora.dmg"'</span> -- --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>图示</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%A0%E9%99%A4%E6%88%AA%E5%9B%BE.png"></p>
<ol start="3">
<li>补充注意点:</li>
</ol>
<p>如果你像我一样,工作区有新写的内容没有追踪与提交导致无法进行删除操作时,千万不要直接暂存<code>stash</code>,否则这些没有暂存的内容就没了,要记得先<code>git add .</code></p>
</blockquote>
<h3 id="Ⅳ-把该文件的引用完全删除"><a href="#Ⅳ-把该文件的引用完全删除" class="headerlink" title="Ⅳ-把该文件的引用完全删除"></a>Ⅳ-把该文件的引用完全删除</h3><blockquote>
<p>上面的命令执行后，此时历史记录中已经没有该文件了，此时是真正删除了它。 不过我们运行 filter-branch 产生的日志还是会对该文件有引用，所以我们还需要运行以下几条命令，把该文件的引用完全删除：</p>
<ol>
<li>命令示例:</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> -rf .git/refs/original/
<span class="token function">git</span> reflog expire --expire<span class="token operator">=</span>now --all
<span class="token function">git</span> gc --prune<span class="token operator">=</span>now
<span class="token function">git</span> gc --aggressive --prune<span class="token operator">=</span>now<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>图示</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510183253770.png" alt="image-20210510183253770"></p>
<ol start="3">
<li>果真编程其实殊途同归,该学的都得学,这里就暴露的 Linux 没学好的弊端,所以暗下决心,争取今年内将 linux 系统学习一遍</li>
</ol>
</blockquote>
<h3 id="Ⅴ-强制提交"><a href="#Ⅴ-强制提交" class="headerlink" title="Ⅴ-强制提交"></a>Ⅴ-强制提交</h3><blockquote>
<p>现在我们再看 .git 文件的大小明显变小了，少了那个大文件，说明我们之前误提交的大文件已经删除了。 最后一步就是 push 代码了，不过就是需要强制 push</p>
<ol>
<li>命令示例</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> push --force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>图示</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4.jpg"></p>
</blockquote>
<h3 id="Ⅵ-远程仓库-GC"><a href="#Ⅵ-远程仓库-GC" class="headerlink" title="Ⅵ-远程仓库 GC"></a>Ⅵ-远程仓库 GC</h3><blockquote>
<p>网上所能百度的方法中都没有说到要进行远程存储库 GC,但是本人操作后发现,明明命令行中运行了<code>git gc</code>,但你的远程仓库仍然会非常庞大甚至更加庞大,也许你本地已经删减至几十兆,但是远程仓库已经”爆仓”达到<code>1300+兆</code>,详见<code>问题7</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510180757993.png" alt="image-20210510180757993"></p>
</blockquote>
<h3 id="Ⅶ-删除前后-git大小对比"><a href="#Ⅶ-删除前后-git大小对比" class="headerlink" title="Ⅶ-删除前后.git大小对比"></a>Ⅶ-删除前后<code>.git</code>大小对比</h3><blockquote>
<p>本人此时测试删除的文件正好为 10M,成功删除</p>
<ol>
<li>删除前截图</li>
</ol>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/删除大文件前大小.png" style="zoom:67%;">

<ol start="2">
<li>删除后截图</li>
</ol>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/删除大文件后大小.png" style="zoom:67%;">

<ol start="3">
<li>删除多个文件后</li>
</ol>
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210508182039450.png" alt="image-20210508182039450" style="zoom:67%;">
</blockquote>
<h2 id="6、git-出现文件夹后面跟-数字问题"><a href="#6、git-出现文件夹后面跟-数字问题" class="headerlink" title="6、git 出现文件夹后面跟@+数字问题"></a>6、git 出现文件夹后面跟<code>@+数字</code>问题</h2><blockquote>
<ol>
<li><p>问题出现场景:本人欲将两个仓库代码合到一个仓库中,但是原本文件夹内还有.git，导致这些文件夹 push 后变成了子模块</p>
</li>
<li><p>问题场景图例–&gt;具体出问题时并没有截图,此处截图提交时差别(原本应该是一大堆 V1.0 的文件,结果只有一个文件夹,后面跟着哈希值)</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510171915185.png" alt="image-20210510171915185"></p>
<ol start="3">
<li>解决思路</li>
</ol>
<blockquote>
<p>删除原来的子文件夹的.git –&gt;<code>rm -r .git</code>,当然也可以手动删除</p>
<p>删除本地 git 缓存 –&gt;<code>git rm -r --cached fileName</code></p>
<p>重新 add，push</p>
</blockquote>
<ol start="4">
<li>解决结果截图</li>
</ol>
  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510172159472.png" alt="image-20210510172159472" style="zoom:67%;">
</blockquote>
<h2 id="7、远程仓库过大导致无法-push"><a href="#7、远程仓库过大导致无法-push" class="headerlink" title="7、远程仓库过大导致无法 push"></a>7、远程仓库过大导致无法 push</h2><blockquote>
<p>问题出现场景:在前两天本人发现笔记仓库过大 已经达到 600M 的时候,本人花了一些时间将无用的大文件删除(详见<code>问题5</code>),并且减小到了 100M+,然后推送上了 gitee 上,但是今天 push 的时候突然报错仓库过大无法推送</p>
<ol>
<li><p>问题报错截图<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510180415796.png" alt="image-20210510180415796"></p>
</li>
<li><p>本人就产生很大的疑惑,明明我本地仓库才 100+M,<code>.git</code>文件也才 86M,但是远程仓库竟然达到了恐怖的 1300M+(当时急于寻找解决方案,没有截图)</p>
</li>
</ol>
<p>本人推测(不确定,也找不到人问,朋友都没经历过这个情况,所以引出记录待定,如果有小伙伴知道了希望可以发在评论区或者私信我)</p>
<ol>
<li><p>当时我是将多条命令一起复制进去运行,可能导致<code>git gc</code>命令没有运行到(可能性极小,但还是留下悔恨的泪水)</p>
</li>
<li><p>也许本地的 gc 命令只是清理了本地仓库的,远程也要清理,但这个并不重要,知道了这个点后我们能进行解决了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510180539437.png" alt="image-20210510180539437" style="zoom:50%;"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510181407805.png" alt="image-20210510181407805" style="zoom:67%;"></p>
</li>
<li><p>问题解决:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510180757993.png" alt="image-20210510180757993"></p>
<p>GC 后内存<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210510181329197.png" alt="image-20210510181329197"></p>
</li>
<li><p>GC 详解</p>
</li>
</ol>
<blockquote>
<p>Git 的底层并没有采用 CVS、SVN 底层所采用的那套增量式文件系统，而是采用一套自行维护的存储文件系统。当文件变动发生提交时，该文件系统存储的不是文件的差异信息，而是文件快照，即整个文件内容，并保存指向快照的索引。这种做法，提高 Git 分支的使用效率；但也容易导致代码仓库中内容重复程度过高，从而仓库体积过大。当遇到这种情况时，或者需要将仓库推送到远程主机时，就需要 Git 中的 gc（garbage collect）功能，也就是<code>垃圾回收功能</code>。</p>
<p>大体来说，当运行 “git gc” 命令时，Git 会收集所有松散对象并将它们存入 packfile，合并这些 packfile 进一个大的 packfile，然后将不被任何 commit 引用并且已存在一段时间 (数月) 的对象删除。 此外，Git 还会将所有引用 (references) 并入一个单独文件。</p>
<p>就细节而言，Git 做了这几件事：</p>
<p>pack_refs 过程<br>reflog expire 过程<br>repack 过程<br>prune 过程<br>rerere 过程</p>
<p>pack_refs 过程相当于执行”git pack-refs –all –prune”，它会将$GIT_DIR&#x2F;refs目录下的所有heads和tags打包成一个文件并保存为$GIT_DIR&#x2F;packed-refs 下。</p>
<p>reflog expire 过程相当于执行”git reflog expire –all”，它会将删除所有超过期限而且没有被 refs 涉及的 reflog 条目。</p>
<p>repack 过程相当于执行”git repack -d -l”，一般情况下还会包括”-A”选项，它会将所有未被包含在一个 pack 的松散对象连结成一个 pack，也会将现有的 pack 重新组织为一个新的更有效率的 pack，并删除冗余的 pack（如果她们中存在不可达的松散对象，会先把这些对象释放出来）。</p>
<p>prune 过程相当于执行”git prune –expire”，他会删除所有过期的、不可达的且未被打包的松散对象。</p>
<p>rerere 过程相当于执行”git rerere gc”，这种情形下似乎没什么用。</p>
<p>所以本人推测应该是进行了<code>问题5</code>操作后还需要<code>进行一次GC操作</code></p>
</blockquote>
</blockquote>
<h2 id="8、Git-GUI-中文乱码问题解决方法"><a href="#8、Git-GUI-中文乱码问题解决方法" class="headerlink" title="8、Git GUI 中文乱码问题解决方法"></a>8、Git GUI 中文乱码问题解决方法</h2><blockquote>
<p>当我们使用 Git GUI 的查看代码的时候，有时候会出现中文乱码：</p>
<ol>
<li><p>解决方案 1:直接在<code>GIT GUI</code>中操作</p>
<p>**<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210701180547401.png" alt="image-20210701180547401"></p>
</li>
<li><p>解决方案 2:命令行</p>
</li>
</ol>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git config --global gui.encoding utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>解决方案 3:直接修改配置文件</li>
</ol>
<blockquote>
<p>在软件的安装目录下，在<code>Git\mingw32\etc\gitconfig</code>文件末尾添加：</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[gui]encoding&#x3D;utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
</blockquote>
<h2 id="9、Git-切换远程仓库地址"><a href="#9、Git-切换远程仓库地址" class="headerlink" title="9、Git 切换远程仓库地址"></a>9、Git 切换远程仓库地址</h2><blockquote>
<p>在公司开发中,也许会遇到公司项目地址迁移的问题(本人就遇到了) : 比如从码云 gitee 上将项目迁移到 gitLab 上,那么我们本地怎么切换远程仓库地址呢? 很简单!</p>
<ol>
<li>切换远程仓库地址</li>
</ol>
<ul>
<li><p><strong>方式一：修改远程仓库地址</strong></p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git remote set-url origin URL #更换远程仓库地址，URL为新地址。一步到胃<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>方式二：先删除远程仓库地址，然后再添加</strong></p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git remote rm origin #删除现有远程仓库
git remote add origin url #添加新远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<ol start="2">
<li>查看远程仓库地址</li>
</ol>
<blockquote>
<p>没错,改完了,很简单是吧,但是你怎么确定自己是否修改成功了呢?</p>
<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git remote -v  #查看远程仓库的地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<ol start="3">
<li>截图示例</li>
</ol>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%88%87%E6%8D%A2%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.png" alt="Git 切换远程仓库地址"></p>
</blockquote>
</blockquote>
<h2 id="10、如何撤销-commit-提交"><a href="#10、如何撤销-commit-提交" class="headerlink" title="10、如何撤销 commit 提交"></a>10、如何撤销 commit 提交</h2><blockquote>
<ol>
<li>一般我们写完代码后,是这样提交的:</li>
</ol>
<ul>
<li>git add . &#x2F;&#x2F;添加追踪所有文件</li>
<li>git commit -m “feat(前端-Git 学习详细笔记):更新撤销 commit 操作” &#x2F;&#x2F;添加 commit 提交信息</li>
</ul>
<ol start="2">
<li>但是 commit 写完提交信息后,突然想到还有一个地方代码没改到&#x2F;保存,如果放到下一个 commit 却不合适(同一个功能修改,分成两个 commit),原因详见上方的 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E2%85%A3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">版本控制工具的使用基本原则</a></li>
<li>执行此命令命令:<code>git reset --soft HEAD^</code></li>
</ol>
<ul>
<li>HEAD^的意思是上一个版本，也可以写成 HEAD~1</li>
<li>如果你进行了 2 次 commit，想都撤回，可以使用 HEAD~2</li>
<li>详见 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#reset%E4%B8%89%E9%83%A8%E6%9B%B2">reset 三部曲</a></li>
</ul>
<p>作用:将文件从<code>暂存区中撤回</code>到工作目录中(仅仅是撤回 commit 操作，你写的代码仍然保留)</p>
</blockquote>
<h2 id="11、错误的-git-push-提交成功后如何撤销回退"><a href="#11、错误的-git-push-提交成功后如何撤销回退" class="headerlink" title="11、错误的 git push 提交成功后如何撤销回退"></a>11、错误的 git push 提交成功后如何撤销回退</h2><blockquote>
<p>我们在使用 Git 进行版本控制时，有可能会出现这种情况。git push 后发现提交的内容不是想要的，这时候我们怎么做呢，提交上去的内容是没有删除按钮的（比如 github，或码云）。所以我们需要一些手段将提交上去内容撤销下来。</p>
<p>而要撤销,就要用到上面所学的 <code>git reset</code></p>
</blockquote>
<h3 id="1、错误场景示范-1"><a href="#1、错误场景示范-1" class="headerlink" title="1、错误场景示范"></a>1、错误场景示范</h3><blockquote>
<p>Ⅰ- 当我撰写 [ commit ] 信息没注意到,以为是对的时候直接提交 –&gt; 因为本人提交笔记时喜欢按 [ ↑ ] 找到之前的提交信息进行修改</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813153403664.png" alt="image-20210813153403664" style="zoom:67%;">

<p>Ⅱ- 此时可以看到,错误的 [ commit ] 已经提交了 (当然,适用场景不只是 commit ,也可错误代码之类的)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813155746112.png" alt="image-20210813155746112"></p>
</blockquote>
<h3 id="2、回退操作-1"><a href="#2、回退操作-1" class="headerlink" title="2、回退操作"></a>2、回退操作</h3><blockquote>
<p>咱们操作稳重一点,使用 git reset –soft HEAD~就好了(如果回退后代码也不想要,可以用<code>git stash</code>,暂存,达到代码也回退的效果)</p>
</blockquote>
<h4 id="①-git-reflog-1"><a href="#①-git-reflog-1" class="headerlink" title="① git reflog"></a>① git reflog</h4><blockquote>
<p>commits，它在 git 中扮演了一个重要角色，我们平常用的一些操作 git clone ,git commit 都会产生 commits，通俗的讲这个就是版本号，但是 git reset 并不会产生 commits（不是不会产生，而是会产生 但是都是一样的），我们可以先看看自己项目中的 commits，使用如下命令:<code>git reflog</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813154309057.png" alt="image-20210813154309057"></p>
</blockquote>
<h4 id="②-git-reset-–soft-HEAD-1"><a href="#②-git-reset-–soft-HEAD-1" class="headerlink" title="② git reset –soft HEAD~"></a>② git reset –soft HEAD~</h4><blockquote>
<p>运行此代码后,我们的 [ HEAD ] 指向了上一个 [ commits ]</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813154448889.png" alt="image-20210813154448889"></p>
</blockquote>
<h4 id="③-查看缓存-1"><a href="#③-查看缓存-1" class="headerlink" title="③ 查看缓存"></a>③ 查看缓存</h4><blockquote>
<ul>
<li><p>此时你可以用<code>stash staus</code>查看,会发现,之前提交的代码已经放回缓存区了</p>
</li>
<li><p>如果你不想要此次提交所有代码,可以使用<code>git stash</code> ,然后再去清空即可(当然,本人此处还是需要的,所以要留下)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813154839981.png" alt="image-20210813154839981"></p>
</li>
</ul>
</blockquote>
<h4 id="④-重新撰写-commit-信息-1"><a href="#④-重新撰写-commit-信息-1" class="headerlink" title="④ 重新撰写 [ commit ]信息"></a>④ 重新撰写 [ commit ]信息</h4><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813154928064.png" alt="image-20210813154928064"></p>
</blockquote>
<h4 id="⑤-强制提交-1"><a href="#⑤-强制提交-1" class="headerlink" title="⑤ 强制提交"></a>⑤ 强制提交</h4><blockquote>
<p>如果你重新撰写 [ commit ] 后马上重新 push,你会发现无法提交: 因为我们当前落后远程一个版本!</p>
<p>所以此时直接强制提交即可,就能覆盖远程提交记录</p>
<blockquote>
<p><code>git push -f</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813155049169.png" alt="image-20210813155049169"></p>
</blockquote>
<h3 id="3、成功展示-1"><a href="#3、成功展示-1" class="headerlink" title="3、成功展示"></a>3、成功展示</h3><blockquote>
<ul>
<li>在网站工作台首页能看到已经将更改后的 [ coommit ] 强制推送上来了</li>
</ul>
<p>也许你会奇怪:为啥工作台上还能看到? 其实已经删了!!!你看下方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813155614570.png" alt="image-20210813155614570"></p>
<ul>
<li>但是你查看提交记录,会发现之前错误的 commit 已经被覆盖</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210813155339300.png" alt="image-20210813155339300" style="zoom:80%;">
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zl-maker.github.io">zl-maker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zl-maker.github.io/2021/12/20/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://zl-maker.github.io/2021/12/20/学习笔记/Git学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zl-maker.github.io" target="_blank">zl-maker的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Git/">Git</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/30/%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%ABSHARE/SHARE/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/zl-maker/DrawingBed@img/image/1650873890286abc-124.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">文章分享系统SHARE</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/zl-maker/DrawingBed@img/image/1650873890286abc-124.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git&amp;vim学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Git&amp;vim学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/zl-maker/DrawingBed@img/image/1650873890286abc-124.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-26</div><div class="title">Git&amp;vim学习笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%85%A0-Git-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">Ⅰ-Git 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">一、初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Git-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text">二、Git 工作流程与区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E3%80%81%E5%9C%A8%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%B8%AD%E4%BF%AE%E6%94%B9%E6%9F%90%E4%BA%9B%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.0.1.</span> <span class="toc-text">①、在工作目录中修改某些文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E3%80%81%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F-%E5%AF%B9%E6%9A%82%E5%AD%98%E5%8C%BA%E5%81%9A%E5%BF%AB%E7%85%A7"><span class="toc-number">1.2.2.0.2.</span> <span class="toc-text">②、保存到暂存区域,对暂存区做快照</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E3%80%81%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0"><span class="toc-number">1.2.2.0.3.</span> <span class="toc-text">③、提交更新</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">三、对象详解(底层命令)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81git-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、git 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5-git-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AF%BB%E5%8F%96-%E5%AD%98%E5%85%A5%E2%80%9D-git-x2F-objects%E2%80%9D"><span class="toc-number">1.3.1.0.1.</span> <span class="toc-text">① 直接写入 git 对象方法与读取(存入”.git&#x2F;objects”)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A0%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、树对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%A0%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">构建树对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%88%A9%E7%94%A8-update-index-%E5%91%BD%E4%BB%A4-%E5%88%9B%E5%BB%BA%E6%9A%82%E5%AD%98%E5%8C%BA"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">① 利用 update-index 命令 创建暂存区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E6%9F%A5%E7%9C%8B%E6%9A%82%E5%AD%98%E5%8C%BA%E5%BD%93%E5%89%8D%E6%A0%B7%E5%AD%90"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">② 查看暂存区当前样子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、提交对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%88%9B%E5%BB%BA%E6%8F%90%E4%BA%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.3.0.1.</span> <span class="toc-text">① 创建提交对象</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">四、高层命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81git-add"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、git add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81git-commit-m-%E2%80%9C%E6%B3%A8%E9%87%8A%E5%86%85%E5%AE%B9%E2%80%9D"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、git commit -m “注释内容”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81git-init"><span class="toc-number">1.4.3.</span> <span class="toc-text">3、git init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81git-status"><span class="toc-number">1.4.4.</span> <span class="toc-text">4、git status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81git-diff"><span class="toc-number">1.4.5.</span> <span class="toc-text">5、git diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81git-log"><span class="toc-number">1.4.6.</span> <span class="toc-text">6、git log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81git-rm"><span class="toc-number">1.4.7.</span> <span class="toc-text">7、git rm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81git-mv"><span class="toc-number">1.4.8.</span> <span class="toc-text">8、git mv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%85%8D%E5%88%AB%E5%90%8D"><span class="toc-number">1.5.</span> <span class="toc-text">五、配别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%88%86%E6%94%AF"><span class="toc-number">1.6.</span> <span class="toc-text">六、分支</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81git-branch"><span class="toc-number">1.6.1.</span> <span class="toc-text">1、git branch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81git-checkout-%E5%88%86%E6%94%AF%E5%90%8D"><span class="toc-number">1.6.2.</span> <span class="toc-text">2、git checkout 分支名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81git-checkout-b-%E2%80%9C%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF%E5%90%8D%E2%80%9D"><span class="toc-number">1.6.3.</span> <span class="toc-text">3、git checkout -b “新的分支名”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A8%A1%E6%8B%9F%E5%AE%9E%E6%88%98%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.4.</span> <span class="toc-text">4、模拟实战流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="toc-number">1.6.5.</span> <span class="toc-text">5、合并分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%AD%98%E5%82%A8"><span class="toc-number">1.7.</span> <span class="toc-text">七、存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81git-stash"><span class="toc-number">1.7.1.</span> <span class="toc-text">1、git stash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81git-stash-list"><span class="toc-number">1.7.2.</span> <span class="toc-text">2、git stash list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81git-stash-pop"><span class="toc-number">1.7.3.</span> <span class="toc-text">3、git stash pop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81git-stash-apply-stash-2"><span class="toc-number">1.7.4.</span> <span class="toc-text">4、git stash apply stash@{2}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81git-stash-drop-%E2%80%9C%E5%82%A8%E8%97%8F%E7%9A%84%E5%90%8D%E5%AD%97%E2%80%9D"><span class="toc-number">1.7.5.</span> <span class="toc-text">5、git stash drop “储藏的名字”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81git-stash-clear"><span class="toc-number">1.7.6.</span> <span class="toc-text">6、git stash clear</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%92%A4%E9%94%80%E4%B8%8E%E9%87%8D%E7%BD%AE"><span class="toc-number">1.8.</span> <span class="toc-text">八、撤销与重置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0-%E6%92%A4%E9%94%80"><span class="toc-number">1.8.1.</span> <span class="toc-text">Ⅰ- 撤销</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81git-commit-%E2%80%93amend"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">1、git commit –amend</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81git-reset"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">2、git reset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81git-checkout"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">3、git checkout</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1-%E9%87%8D%E7%BD%AE-reset"><span class="toc-number">1.8.2.</span> <span class="toc-text">Ⅱ - 重置 reset</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reset-%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">reset 三部曲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2-%E9%94%99%E8%AF%AF%E7%9A%84-git-push-%E6%8F%90%E4%BA%A4%E6%88%90%E5%8A%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80%E5%9B%9E%E9%80%80"><span class="toc-number">1.8.3.</span> <span class="toc-text">Ⅲ - 错误的 git push 提交成功后如何撤销回退</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%94%99%E8%AF%AF%E5%9C%BA%E6%99%AF%E7%A4%BA%E8%8C%83"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1、错误场景示范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2、回退操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-git-reflog"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">① git reflog</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-git-reset-%E2%80%93soft-HEAD"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">② git reset –soft HEAD~</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E6%9F%A5%E7%9C%8B%E7%BC%93%E5%AD%98"><span class="toc-number">1.8.3.2.3.</span> <span class="toc-text">③ 查看缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E9%87%8D%E6%96%B0%E6%92%B0%E5%86%99-commit-%E4%BF%A1%E6%81%AF"><span class="toc-number">1.8.3.2.4.</span> <span class="toc-text">④ 重新撰写 [ commit ]信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4-%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4"><span class="toc-number">1.8.3.2.5.</span> <span class="toc-text">⑤ 强制提交</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%88%90%E5%8A%9F%E5%B1%95%E7%A4%BA"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">3、成功展示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-number">1.9.</span> <span class="toc-text">九、数据恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D-%E6%8E%A8%E8%8D%90%E7%9A%84"><span class="toc-number">1.9.2.</span> <span class="toc-text">恢复 推荐的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%89%93-tag"><span class="toc-number">1.10.</span> <span class="toc-text">十、打 tag</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%97%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="toc-number">1.10.1.</span> <span class="toc-text">1、列出标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE"><span class="toc-number">1.10.2.</span> <span class="toc-text">2、创建标签</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%BD%BB%E9%87%8F%E6%A0%87%E7%AD%BE"><span class="toc-number">1.10.2.0.1.</span> <span class="toc-text">① 轻量标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E9%99%84%E6%B3%A8%E6%A0%87%E7%AD%BE"><span class="toc-number">1.10.2.0.2.</span> <span class="toc-text">② 附注标签</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E6%A0%87%E7%AD%BE"><span class="toc-number">1.10.3.</span> <span class="toc-text">3、查看特定标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%88%A0%E9%99%A4%E6%A0%87%E7%AD%BE"><span class="toc-number">1.10.4.</span> <span class="toc-text">4、删除标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%8D%A1%E5%87%BA%E6%A0%87%E7%AD%BE"><span class="toc-number">1.10.5.</span> <span class="toc-text">5、捡出标签</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%85%A1-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.</span> <span class="toc-text">Ⅱ-代码风格</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Eslint"><span class="toc-number">2.1.</span> <span class="toc-text">1、Eslint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81commit-%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.</span> <span class="toc-text">2、commit 提交规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%85%A2-%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">Ⅲ-远程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.0.1.</span> <span class="toc-text">1、团队协作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BF%9C%E7%A8%8B%E5%BA%93"><span class="toc-number">3.0.2.</span> <span class="toc-text">2、远程库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%85%A0-%E8%BF%9C%E7%A8%8B%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">Ⅰ-远程跟踪分支</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9A%E8%B7%9F%E8%B8%AA"><span class="toc-number">3.0.2.1.1.</span> <span class="toc-text">做跟踪</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%85%A1-%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E6%80%8E%E4%B9%88%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E8%B7%9F%E8%B8%AA%E5%88%86%E6%94%AF"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">Ⅱ-本地分支怎么跟踪远程跟踪分支</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%85%A2-%E5%86%B2%E7%AA%81"><span class="toc-number">3.0.2.3.</span> <span class="toc-text">Ⅲ-冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%85%A3-pull-request-%E6%B5%81%E7%A8%8B"><span class="toc-number">3.0.2.4.</span> <span class="toc-text">Ⅳ- pull request 流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%85%A3-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">4.</span> <span class="toc-text">Ⅳ-版本控制工具的使用基本原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B2%BE%E5%87%86%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="toc-number">4.1.</span> <span class="toc-text">1、精准的提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%A2%91%E7%B9%81%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="toc-number">4.2.</span> <span class="toc-text">2、频繁的提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%8D%E8%A6%81%E6%8F%90%E4%BA%A4%E4%B8%8D%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.3.</span> <span class="toc-text">3、不要提交不完整的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%8F%90%E4%BA%A4%E5%89%8D%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">4.4.</span> <span class="toc-text">4、提交前进行测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E6%8F%90%E4%BA%A4%E6%B3%A8%E9%87%8A"><span class="toc-number">4.5.</span> <span class="toc-text">5、高质量的提交注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E9%81%B5%E5%BE%AA%E7%BB%9F%E4%B8%80%E7%9A%84%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83"><span class="toc-number">4.6.</span> <span class="toc-text">6、遵循统一的流程规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%85%A4-%E5%AE%9E%E9%99%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3-Mark"><span class="toc-number">5.</span> <span class="toc-text">Ⅴ- 实际遇到的问题与解决 Mark</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%B0%86%E6%9C%AC%E5%9C%B0%E5%B7%B2%E6%9C%89%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%96%B0%E5%BB%BA%E7%9A%84-git-%E4%BB%93%E5%BA%93%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">1、将本地已有的一个项目上传到新建的 git 仓库的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0-%E5%85%8B%E9%9A%86-%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.1.1.</span> <span class="toc-text">Ⅰ- 克隆+拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%A6%96%E5%85%88%E5%85%8B%E9%9A%86"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">1、首先克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%84%B6%E5%90%8E%E5%A4%8D%E5%88%B6%E8%87%AA%E5%B7%B1%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6-%E9%99%A4%E4%BA%86-git%E6%96%87%E4%BB%B6-%E5%88%B0%E5%88%9A%E5%88%9A%E5%85%8B%E9%9A%86%E4%B8%8B%E6%9D%A5%E7%9A%84%E4%BB%93%E5%BA%93%E4%B8%AD"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">2、然后复制自己项目的所有文件(除了.git文件)到刚刚克隆下来的仓库中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9C%80%E5%90%8E-push-%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8A%E9%9D%A2%E5%8E%BB"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">3、最后 push 到远程仓库上面去</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1-%E5%BC%BA%E8%A1%8C%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E4%BB%93%E5%BA%93"><span class="toc-number">5.1.2.</span> <span class="toc-text">Ⅱ- 强行合并两个仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%96%B0%E5%BB%BA-git-%E4%BB%93%E5%BA%93%EF%BC%8C%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%80%E4%B8%AA-git-%E4%BB%93%E5%BA%93%E3%80%82%E5%A6%82%E6%9E%9C%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%B7%B2%E7%BB%8F%E6%98%AF%E4%B8%80%E4%B8%AA-git-%E4%BB%93%E5%BA%93%E4%BA%86%EF%BC%8C%E8%AF%B7%E8%B7%B3%E8%BF%87%E8%BF%99%E4%B8%80%E6%AD%A5%E3%80%82%E5%9C%A8%E9%A1%B9%E7%9B%AE%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">1、新建 git 仓库，将本地项目设置为一个 git 仓库。如果本地项目已经是一个 git 仓库了，请跳过这一步。在项目根目录下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%8A%8A%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%B7%B2%E6%9C%89%E6%96%87%E4%BB%B6-%E9%99%A4%E4%BA%86-git%E6%96%87%E4%BB%B6-%E5%85%A8%E9%83%A8%E5%8A%A0%E5%88%B0%E5%88%9A%E5%88%9A%E6%96%B0%E5%BB%BA%E7%9A%84-git-%E4%BB%93%E5%BA%93%E4%B8%AD"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">2、把当前目录下的已有文件(除了.git文件)全部加到刚刚新建的 git 仓库中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%BF%9D%E5%AD%98%E5%88%9A%E5%88%9A%E5%8A%A0%E5%85%A5%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E4%B9%A6%E5%86%99%E4%BF%9D%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="toc-number">5.1.2.3.</span> <span class="toc-text">3、保存刚刚加入的文件，并书写保存信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5"><span class="toc-number">5.1.2.4.</span> <span class="toc-text">4、将本地仓库与远程仓库关联起来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81pull-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%8C%E4%BD%BF%E7%94%A8%E2%80%93allow-unrelated-histories-%E5%BF%BD%E7%95%A5%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E6%97%A0%E5%85%B3%E6%80%A7%EF%BC%8C%E5%BC%BA%E8%A1%8C%E5%90%88%E5%B9%B6%EF%BC%88%E5%85%B3%E9%94%AE%EF%BC%89"><span class="toc-number">5.1.2.5.</span> <span class="toc-text">5、pull 远程仓库的内容，更新本地仓库，使用–allow-unrelated-histories 忽略本地仓库和远程仓库的无关性，强行合并（关键）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%8A%8A%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%86%85%E5%AE%B9-push-%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">5.1.2.6.</span> <span class="toc-text">6、把本地仓库的内容 push 到远程仓库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2-%E5%85%B6%E4%BB%96-git-%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.3.</span> <span class="toc-text">Ⅲ- 其他 git 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E5%86%B3%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%94%9F%E6%88%90%E4%B8%A4%E4%BB%BD%E6%88%96%E5%A4%9A%E4%BB%BD-ssh-%E5%AF%86%E9%92%A5%E3%80%81%E5%85%AC%E9%92%A5%E6%98%A0%E5%B0%84%E4%B8%A4%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA-GitHub-%E8%B4%A6%E5%8F%B7"><span class="toc-number">5.2.</span> <span class="toc-text">2、解决同一台电脑生成两份或多份 ssh 密钥、公钥映射两个或多个 GitHub 账号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">5.2.1.</span> <span class="toc-text">Ⅰ- 需求分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%80%9D%E8%B7%AF"><span class="toc-number">5.2.2.</span> <span class="toc-text">Ⅱ- 解决方案思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2-%E7%94%9F%E6%88%90%E6%96%B0-ssh-key"><span class="toc-number">5.2.3.</span> <span class="toc-text">Ⅲ- 生成新 ssh key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A3-%E6%B7%BB%E5%8A%A0%E6%96%B0-ssh-key"><span class="toc-number">5.2.4.</span> <span class="toc-text">Ⅳ- 添加新 ssh key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A4-%E9%85%8D%E7%BD%AE-config-%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.5.</span> <span class="toc-text">Ⅴ- 配置 config 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A5-%E6%B5%8B%E8%AF%95%E6%98%AF%E5%90%A6%E9%85%8D%E7%BD%AE%E6%88%90%E5%8A%9F"><span class="toc-number">5.2.6.</span> <span class="toc-text">Ⅵ- 测试是否配置成功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A6-%E9%97%AE%E9%A2%98-Mark"><span class="toc-number">5.2.7.</span> <span class="toc-text">Ⅶ- 问题 Mark</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">5.2.7.1.</span> <span class="toc-text">此问题解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81commit-%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4"><span class="toc-number">5.3.</span> <span class="toc-text">3、commit 报错无法提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Git-%E6%8F%90%E4%BA%A4%E6%97%B6%E5%87%BA%E7%8E%B0-%E5%90%88%E5%B9%B6%E6%8F%90%E7%A4%BA-Merge-branch-39-master-39-of-%E4%B9%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">4、Git 提交时出现(合并提示)Merge branch &#39;master&#39; of ...之解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0-%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%94%99error-Cannot-pull-with-rebase"><span class="toc-number">5.4.1.</span> <span class="toc-text">① 可能出现的相关报错error:Cannot pull with rebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1-%E9%98%B2%E6%AD%A2%E5%86%B2%E7%AA%81%E7%9A%84%E6%9C%89%E6%95%88%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.2.</span> <span class="toc-text">② 防止冲突的有效操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Git-%E5%88%A0%E9%99%A4%E8%AF%AF%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95"><span class="toc-number">5.5.</span> <span class="toc-text">5、Git 删除误提交的大文件历史记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A0-%E5%88%97%E5%87%BA%E4%BB%93%E5%BA%93%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-number">5.5.1.</span> <span class="toc-text">Ⅰ-列出仓库中最大的几个对象及其文件名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A1-%E5%B0%86%E6%9F%90%E6%96%87%E4%BB%B6%E4%BB%8E%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E4%B8%AD%E5%88%A0%E9%99%A4"><span class="toc-number">5.5.2.</span> <span class="toc-text">Ⅱ-将某文件从历史记录中删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A2-%E9%87%8D%E5%86%99%E6%89%80%E6%9C%89-commit%EF%BC%8C%E5%B0%86%E8%AF%A5%E6%96%87%E4%BB%B6%E4%BB%8E-Git-%E5%8E%86%E5%8F%B2%E4%B8%AD%E5%AE%8C%E5%85%A8%E5%88%A0%E9%99%A4"><span class="toc-number">5.5.3.</span> <span class="toc-text">Ⅲ-重写所有 commit，将该文件从 Git 历史中完全删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A3-%E6%8A%8A%E8%AF%A5%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%95%E7%94%A8%E5%AE%8C%E5%85%A8%E5%88%A0%E9%99%A4"><span class="toc-number">5.5.4.</span> <span class="toc-text">Ⅳ-把该文件的引用完全删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A4-%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4"><span class="toc-number">5.5.5.</span> <span class="toc-text">Ⅴ-强制提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A5-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93-GC"><span class="toc-number">5.5.6.</span> <span class="toc-text">Ⅵ-远程仓库 GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%85%A6-%E5%88%A0%E9%99%A4%E5%89%8D%E5%90%8E-git%E5%A4%A7%E5%B0%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">5.5.7.</span> <span class="toc-text">Ⅶ-删除前后.git大小对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81git-%E5%87%BA%E7%8E%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8E%E9%9D%A2%E8%B7%9F-%E6%95%B0%E5%AD%97%E9%97%AE%E9%A2%98"><span class="toc-number">5.6.</span> <span class="toc-text">6、git 出现文件夹后面跟@+数字问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E8%BF%87%E5%A4%A7%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95-push"><span class="toc-number">5.7.</span> <span class="toc-text">7、远程仓库过大导致无法 push</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Git-GUI-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.</span> <span class="toc-text">8、Git GUI 中文乱码问题解决方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Git-%E5%88%87%E6%8D%A2%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80"><span class="toc-number">5.9.</span> <span class="toc-text">9、Git 切换远程仓库地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80-commit-%E6%8F%90%E4%BA%A4"><span class="toc-number">5.10.</span> <span class="toc-text">10、如何撤销 commit 提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E9%94%99%E8%AF%AF%E7%9A%84-git-push-%E6%8F%90%E4%BA%A4%E6%88%90%E5%8A%9F%E5%90%8E%E5%A6%82%E4%BD%95%E6%92%A4%E9%94%80%E5%9B%9E%E9%80%80"><span class="toc-number">5.11.</span> <span class="toc-text">11、错误的 git push 提交成功后如何撤销回退</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%94%99%E8%AF%AF%E5%9C%BA%E6%99%AF%E7%A4%BA%E8%8C%83-1"><span class="toc-number">5.11.1.</span> <span class="toc-text">1、错误场景示范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9B%9E%E9%80%80%E6%93%8D%E4%BD%9C-1"><span class="toc-number">5.11.2.</span> <span class="toc-text">2、回退操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-git-reflog-1"><span class="toc-number">5.11.2.1.</span> <span class="toc-text">① git reflog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-git-reset-%E2%80%93soft-HEAD-1"><span class="toc-number">5.11.2.2.</span> <span class="toc-text">② git reset –soft HEAD~</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E6%9F%A5%E7%9C%8B%E7%BC%93%E5%AD%98-1"><span class="toc-number">5.11.2.3.</span> <span class="toc-text">③ 查看缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-%E9%87%8D%E6%96%B0%E6%92%B0%E5%86%99-commit-%E4%BF%A1%E6%81%AF-1"><span class="toc-number">5.11.2.4.</span> <span class="toc-text">④ 重新撰写 [ commit ]信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4-%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4-1"><span class="toc-number">5.11.2.5.</span> <span class="toc-text">⑤ 强制提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%88%90%E5%8A%9F%E5%B1%95%E7%A4%BA-1"><span class="toc-number">5.11.3.</span> <span class="toc-text">3、成功展示</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By zl-maker</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'kE03tPxUEHfGNeQ0I3yqCBrw-MdYXbMMI',
      appKey: '9ArAjrdANNKoxtInh2m69kCN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, ))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "aac0f29d-6efb-4653-a116-8790585c4332";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (true) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>